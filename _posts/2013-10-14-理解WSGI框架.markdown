---
layout: post
title:  "理解 WSGI 框架"
categories: Architectrue
---

--------------------
&nbsp;&nbsp;&nbsp;

> This document specifies a proposed standard interface between web servers and Python web applications or frameworks, to promote web application portability across a variety of web servers.
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\------PEP 0333


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;![wsgi](http://7xp2eu.com1.z0.glb.clouddn.com/Python-Visual.jpg)

------------------

# An Introduction to WSGI

Java web 开发者可能知道：所有支持 servlet API 的 java application/framework 都可以运行在支持 servlet API 的 web server(http server) 上。随着 web 不断的发展，python 的应用/框架也如雨后春笋般涌出，如：Zope, Webware, Skunkweb 等等。但是它们接口存在差异，导致难以跨 web server 运行，所以 python 社区定义了一种标准通用的接口---WSGI。

[PEP 0333 -- Python Web Server Gateway Interface](https://www.python.org/dev/peps/pep-0333) 是一种 [web server](https://en.wikipedia.org/wiki/Web_server)(or gateway) 和 python [web application](https://en.wikipedia.org/wiki/Application_server)(or framework) 之间简单通用的接口，符合这种接口标准的 application 可运行在多种同样符合该标准的 server 上。通俗的讲，WSGI 规范了一种简单的接口，解耦了 server 和 application，使得双方的开发者更加专注自身特性的开发。首先解释 web server 和 python web application。

- Web server/gateway: 即 HTTP Server，接受用户 HTTP 请求，处理 HTTP 协议和提供并发，调用 web application 处理逻辑业务。通常采用 C/C++ 编写，代表：apache, nginx 和 IIS。
- Python Web application/framework: 专注逻辑业务的 python 应用或者框架。

![wsgi framework](http://7xp2eu.com1.z0.glb.clouddn.com/wsgiframework.png)

---------------------

# The Application/Framework Side

Application/framework 必须定义一个 callable object，callable object 可以是以下三者之一：

- function, method
- class
- instance with a \_\_call\_\_ method

Callable object 必须满足以下两个条件：

- 接受两个参数：字典(通常是 environ)，回调函数(通常是 start_response，返回 HTTP status，headers 给 http server)
- 返回一个可迭代的值

基于 callable function 的 application/framework 例子如下：

~~~ python
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/plain')])
    return ['This is a python application!']
~~~

基于 callable class 的 application/framework 例子如下：

~~~ python
class ApplicationClass(object):
    def __init__(self, environ, start_response):
        self.environ = environ
        self.start_response = start_response

    def __iter__(self):
        self.start_response('200 OK', [('Content-type', 'text/plain')])
        yield "Hello world!\n"
~~~

------------------------

# The Server/Gateway Side

。WSGI 框架中下的 server/gateway 主要专注 HTTP 层面的业务，重点是接收 HTTP 请求。每当收到 HTTP 请求，server/gateway 必须调用 callable object：

- 接收 HTTP 请求，但是不关心 HTTP url, HTTP Method，url 的 mapping 由 application/framework 端完成
- 为 []environ 准备必要的数字，实现一个回调函数 [start_response](https://www.python.org/dev/peps/pep-0333/#id21)，传给 callable object
- 调用 callable object

我们直接使用支持 wsgi 框架的 wsgiref 库，编写一个完整的例子：

~~~ python
# application/framework side
def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/plain')])
    return ['This is a python application!']

# server/gateway side
if __name__ == '__main__':
    from wsgiref.simple_server import make_server
    server = make_server('0.0.0.0', 8080, application)
    server.serve_forever()
~~~ 

运行后，对于任意的 url 和 method，本例的返回值均为 'This is a python application!'：

~~~ bash
$curl 127.0.0.1:8080
This is a python application!                                                                                                                                                                                                                                                  

$ curl 127.0.0.1:8080/test
This is a python application!
~~~

------------------------

# Middleware: Components that Play Both Sides

> Unix philosophy: do one thing and do it well.

Note that a single object may play the role of a server with respect to some application(s), while also acting as an application with respect to some server(s). Such "middleware" components can perform such functions as:

- Routing a request to different application objects based on the target URL, after rewriting the environ accordingly.
- Allowing multiple applications or frameworks to run side-by-side in the same process
- Load balancing and remote processing, by forwarding requests and responses over a network
- Perform content postprocessing, such as applying XSL stylesheets

~~~ python
class IPAuditMiddleware(object):
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        ip_addr = environ.get('HTTP_HOST').split(':')[0]
        if ip_addr not in ('127.0.0.1'):
            return forbidden(start_response)

        return self.app(environ, start_response)


def forbidden(start_response):
    start_response('403 Forbidden', [('Content-Type', 'text/plain')])
    return ['Forbidden']


def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/plain')])
    return ['This is a python application!']


if __name__ == '__main__':
    from wsgiref.simple_server import make_server
    application = IPAuditMiddleware(application)
    server = make_server('0.0.0.0', 8080, application)
    server.serve_forever()
~~~

测试如下：

~~~ bash
# 从本机测试
$ curl 127.0.0.1:8080/test
This is a python application!

# 从其它主机测测试                                                                                                                                                                                                 
$ curl 10.10.10.2:8080/test                                                                                                                                                                                                                                    Forbidden                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ~~~

---------------------------

# Path Dispatching

至此样例存在一个不足之处，那就是对于任意的 url 和 method，程序的返回值均为 'This is a python application!'，所以我们需要增加 path dispatch 功能。由于 WSGI 框架下的 server/gateway 不处理 url 和 method，所以 url mapping 需由 application/framework 端完成。注意到参数 [environ](https://www.python.org/dev/peps/pep-0333/#environ-variables)，它包含以下变量：

- REQUEST_METHOD: 即 HTTP Method
- PATH_INFO: 即 HTTP url

所以 application/framework 可以根据 environ 的 REQUEST_METHOD 和 PATH_INFO 实现 path dispatch，样例如下：

~~~ python
class IPAuditMiddleware(object):
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        ip_addr = environ.get('HTTP_HOST').split(':')[0]
        if ip_addr not in ('127.0.0.1'):
            return forbidden(start_response)

        return self.app(environ, start_response)


def dog(start_response):
    start_response('200 OK', [('Content-Type', 'text/plain')])
    return ['This is dog!']


def cat(start_response):
    start_response('200 OK', [('Content-Type', 'text/plain')])
    return ['This is cat!']


def not_found(start_response):
    start_response('404 NOT FOUND', [('Content-Type', 'text/plain')])
    return ['Not Found']


def forbidden(start_response):
    start_response('403 Forbidden', [('Content-Type', 'text/plain')])
    return ['Forbidden']


def application(environ, start_response):
    path = environ.get('PATH_INFO', '').lstrip('/')
    mapping = {'dog': dog, 'cat': cat}

    call_back = mapping[path] if path in mapping else not_found
    return call_back(start_response)


if __name__ == '__main__':
    from wsgiref.simple_server import make_server
    application = IPAuditMiddleware(application)
    server = make_server('0.0.0.0', 8080, application)
    server.serve_forever()
~~~

测试如下：

~~~ bash
$ curl 127.0.0.1:8080/dog
This is dog!                                                                                                                                                                                                                                                                   

$ curl 127.0.0.1:8080/cat
This is cat!                                                                                                                                                                                                                                                                   

$ curl 127.0.0.1:8080/monkey
Not Found
~~~

