<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>koala bear</title>
    <description>观水有术，必观其澜，日月有明，容光必照。
</description>
    <link>http://wsfdl.com/</link>
    <atom:link href="http://wsfdl.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 24 Feb 2016 21:42:46 +0800</pubDate>
    <lastBuildDate>Wed, 24 Feb 2016 21:42:46 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>从 Helion OpenStack 浅谈 OpenStack 的产品化</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;id-ecosystem-vs-product&quot;&gt;Ecosystem VS Product&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/EcosystemandProduct.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id-openstack&quot;&gt;OpenStack&lt;/h2&gt;

&lt;p&gt;确切的说，OpenStack 更像一个生态系统，从硬件、软件到服务，覆盖了计算、存储、网络和安全等领域，截止到 2016 Feb，OpenStack Community 共有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;36008 people&lt;/li&gt;
  &lt;li&gt;20M+ lines of code&lt;/li&gt;
  &lt;li&gt;177 countries&lt;/li&gt;
  &lt;li&gt;563 supporting companies&lt;/li&gt;
  &lt;li&gt;600+ project&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虽然 OpenStack 提供了丰富的功能，但是很多项目的成熟度和稳定性还有待商榷，并且其安装和运维也并非易事。&lt;/p&gt;

&lt;h2 id=&quot;id-helion&quot;&gt;Helion&lt;/h2&gt;

&lt;p&gt;Helion OpenStack 基于 OpenStack 并对其修枝裁叶，为企业提供自助服务平台和简化管理，并帮助开发人员快速交付应用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对运维而言，简化管理，更易部署和运维&lt;/li&gt;
  &lt;li&gt;对开发人员，提供丰富的自助服务，支持快速获取资源&lt;/li&gt;
  &lt;li&gt;对业务而言，更为稳定，安全可靠&lt;/li&gt;
  &lt;li&gt;对企业而言，提高资源利用率，节省成本，提高效率&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-openstack-&quot;&gt;浅谈 OpenStack 的产品化&lt;/h1&gt;

&lt;p&gt;下图从 Security, High availability, Extend service, Operation 和 HPE 的角度分析 Helion 在产品化 OpenStack 所做的工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/Helion1.png&quot; alt=&quot;Helion1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id-security&quot;&gt;Security&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;SSL：所有的 Public Endpoint 必须支持 HTTPS，以保证 HTTP 通信的安全。&lt;/li&gt;
  &lt;li&gt;Keystone：&lt;/li&gt;
  &lt;li&gt;Network：默认采用 VLAN 某型，&lt;/li&gt;
  &lt;li&gt;AppArmor：增强宿主机系统的安全&lt;/li&gt;
  &lt;li&gt;ArcSight：日志监控与告警&lt;/li&gt;
  &lt;li&gt;Data Encryption：敏感数据加密，诸如涉及密码的配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id-hpe-&quot;&gt;HPE 差异化&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Hardware：HPE 的 x86 服务器，网络设备等&lt;/li&gt;
  &lt;li&gt;Hlinux：HPE Linux&lt;/li&gt;
  &lt;li&gt;Storm &amp;amp; Vertica：HPE 大数据分析和存储软件&lt;/li&gt;
  &lt;li&gt;VSA &amp;amp; 3PAR：HPE 分布式存储&lt;/li&gt;
  &lt;li&gt;Sherpa：HPE 云生态&lt;/li&gt;
  &lt;li&gt;HPE Portal&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id-high-availability&quot;&gt;High Availability&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Controller HA：采用 Haproxy 和 IP Cluster 保证控制节点高可靠性&lt;/li&gt;
  &lt;li&gt;Database HA：采用 Galera Cluster 保证数据库高可靠性&lt;/li&gt;
  &lt;li&gt;RabbitMQ HA：采用 RabbitMQ Cluster 保证消息中间件的可靠性&lt;/li&gt;
  &lt;li&gt;Network HA：采用 Neutron DVR 避免网络节点的单点故障&lt;/li&gt;
  &lt;li&gt;Storage HA：采用 Ceph，VSA 等分布式存储软件保证存储的高可靠性&lt;/li&gt;
  &lt;li&gt;Freezer：支持备份宿主机的文件系统&lt;/li&gt;
  &lt;li&gt;AZ &amp;amp; Region：多区域，多机房部署&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id-extend-service&quot;&gt;Extend Service&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ELK：提供日志的搜集、存储和检索&lt;/li&gt;
  &lt;li&gt;Mail Alarm：提供邮件通知服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;id-operation&quot;&gt;Operation&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Package：维护上百个安装包&lt;/li&gt;
  &lt;li&gt;Deployment：提供自动化快速部署功能&lt;/li&gt;
  &lt;li&gt;Automation：简化运维工作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/Helion2.png&quot; alt=&quot;Helion2&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/algorithm/2016/02/17/HelionOpenStack.html</link>
        <guid isPermaLink="true">http://wsfdl.com/algorithm/2016/02/17/HelionOpenStack.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>理解 RSA 算法</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;id-public-key-cryptography-&quot;&gt;Public-key Cryptography 简介&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Public-key_cryptography&quot;&gt;Public-key cryptography&lt;/a&gt;&lt;br /&gt;
(公开密钥加密) 又称 asymmetric cryptography (非对称加密)，即存在两把不同的密钥，分别称为公钥 Pu 和私钥 Pr，公钥通常用来加密明文 M，只有私钥才能解密密文 C，如果用 E 和 D 分别表示加密和解密算法，那么有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C = E(Pu, M)
M = D(Pr, C)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图(摘自维基百科)形象的表述了加密和解密流程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/500px-Public-key-crypto-1.svg.png?imageView2/1/w/300/h/300/q/100&quot; alt=&quot;P1&quot; /&gt;     &lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/500px-Public_key_encryption.svg.png?imageView2/1/w/300/h/300/q/100&quot; alt=&quot;P2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;传统的对称加密需双方共享相同的密钥，通信安全很大程度依赖双方是否能妥善的管理密钥。公开密钥加密发明是密码学最为重要的里程碑之一，它从数学的角度保证了通信安全。公开密钥加密体系有三大范畴：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Encryption/Decryption：即加密与解密，发送方用接收方的公钥加密消息&lt;/li&gt;
  &lt;li&gt;Digital Signature：数字签名，发送方用私钥加密消息摘要生成签名，保证消息的完整性和可靠性&lt;/li&gt;
  &lt;li&gt;Key Exchange：安全的交换密钥，通常用于交换对称加密的密钥&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;公钥加密有多种算法，最有名的的是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95&quot;&gt;RSA&lt;/a&gt; 和 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B&quot;&gt;DH&lt;/a&gt; 等，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+----------------+-----------------------+-------------------+--------------+
|   Algorithm    | Encryption/Decryption | Digital Signature | Key Exchange |
+----------------+-----------------------+-------------------+--------------+
|      RSA       |          Yes          |        Yes        |      Yes     |
+----------------+-----------------------+-------------------+--------------+
| Deffie-Hellman |          No           |        No         |      Yes     |
+----------------+-----------------------+-------------------+--------------+
| Elliptic Curve |          Yes          |        Yes        |      Yes     |
+----------------+-----------------------+-------------------+--------------+
|      DSS       |          No           |        Yes        |      No      |
+----------------+-----------------------+-------------------+--------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-section&quot;&gt;数论知识&lt;/h1&gt;

&lt;p&gt;理解 RSA 算法前，先介绍一些必要的数论领域知识。&lt;/p&gt;

&lt;h2 id=&quot;id-section-1&quot;&gt;欧拉函数&lt;/h2&gt;

&lt;p&gt;对正整数 n，&lt;a href=&quot;https://en.wikipedia.org/wiki/Euler%27s_totient_function&quot;&gt;欧拉函数&lt;/a&gt; 指小于 n 且与 n 互质的正整数数目，通常用 φ(n) 表示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;对于素数 p，有：   
φ(p) = p - 1   
对于素数 p, q 有：   
φ(p * q) = φ(p) * φ(q) = (p - 1) * (q - 1)   
如 φ(21) = 2 * 6 = 12
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;id-section-2&quot;&gt;欧拉定理&lt;/h2&gt;

&lt;p&gt;对于正整数 a 和 n，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)&quot;&gt;欧拉定理&lt;/a&gt;有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a^φ(n) mod n = 1
即：a^(φ(n) + 1) mod n = a mod n
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;id-section-3&quot;&gt;模反元素&lt;/h2&gt;

&lt;p&gt;当 a, n 互质，一定存在&lt;a href=&quot;https://zh.wikipedia.org/zh/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0&quot;&gt;模仿元素&lt;/a&gt; b，使得：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a * b mod n = 1
由欧拉定理可知：
1 = a^φ(n) mod n = a * a^(φ(n) - 1) mod n
可求得一个 b = a^(φ(n) - 1)，满足 a * b mod n = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-rsa-&quot;&gt;RSA 算法原理&lt;/h1&gt;

&lt;h2 id=&quot;id-rsa--1&quot;&gt;RSA 简介&lt;/h2&gt;

&lt;p&gt;RSA 算法于 1977 由 Ron Rivest，Adi Shamir 和 Leonard Adleman 提出，是目前应用最为广泛的非对称加密算法。极大数&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3&quot;&gt;分解&lt;/a&gt;难题是 RSA 算法可靠性的根基，即给定两个大素数 p 和 q，其中 n = p * q，有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;已知 p、q，求 n = p * q 很容易    
已知 n，求 p、q，并且 p * q = n 很困难
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;id-rsa--2&quot;&gt;RSA 原理&lt;/h2&gt;

&lt;p&gt;对于明文 M 和 密文 C，且 M &amp;lt; n, C &amp;lt; n，其加密和解密过程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C = M^e mod n
M = C^d mod n

上述公式可表述为：
M = M^(e * d) mod n

根据欧拉定理可知:
只需 e * d mod φ(n) = 1，即可满足上式

如果我们选取素数 p, q，那么：
n = p * q 容易计算
φ(n) = (p - 1) * (q - 1) 容易计算
很容易选取一个正整数 e，e 和 φ(n) 互质

当 e 和 φ(n) 互质时：
由欧拉定理可很容易算出一个模反元素 d，满足 e * d mod φ(n) = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;id-rsa--3&quot;&gt;RSA 流程&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695&quot;&gt;Cryptography and Network Security&lt;/a&gt; 形象的描述了 RSA 流程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------------------------------------------------------------------------------+
|                                 Key Generation                                |
|                                                                               |
|     Select p, q                               p and q both prime, p != q      |
|     Calculate n = p * q                                                       |
|     Calculate φ(n) = (p - 1) * (q - 1)                                        |
|     Select integer e                          e is relatively primte to φ(n)  |
|     Calculate d                               (d * e) mod n = 1               |
|     Public key                                PU = {e, n}                     |
|     Private key                               PR = {d, n}                     |
+-------------------------------------------------------------------------------+
+-------------------------------------------------------------------------------+
|                                  Encryption                                   |
|                                                                               |
|     Plaintext M                               M &amp;lt; n                           |
|     Ciphertext C                              C = M^e mod n                   |
+-------------------------------------------------------------------------------+
+-------------------------------------------------------------------------------+
|                                  Decryption                                   |
|                                                                               |
|     Ciphertext C                              C                               |
|     Plaintext M                               M = C^d mod n                   |
+-------------------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 11 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/algorithm/2016/02/11/%E7%90%86%E8%A7%A3RSA%E7%AE%97%E6%B3%95.html</link>
        <guid isPermaLink="true">http://wsfdl.com/algorithm/2016/02/11/%E7%90%86%E8%A7%A3RSA%E7%AE%97%E6%B3%95.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>理解 Deffie-Hellman 密钥交换算法</title>
        <description>&lt;hr /&gt;
&lt;p&gt;    &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;再拾此书时，怀念 4 年前阳光明媚的午后，我在浙大紫金港图书馆的三楼，梦回了中学奥数的小伙伴，和那时曾想证明哥德巴尔猜想的情怀！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;id-deffie-hellman-&quot;&gt;Deffie-Hellman 算法简介&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange&quot;&gt;Deffie-Hellman&lt;/a&gt;(简称 DH) 密钥交换是最早的密钥交换算法之一，它使得通信的双方能在非安全的信道中安全的交换密钥，用于加密后续的通信消息。 Whitfield Diffie 和 Martin Hellman 于 1976 提出该算法，之后被应用于安全领域，比如 Https 协议的 TSL(&lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;Transport Layer Security&lt;/a&gt;) 和 IPsec 协议的 IKE(&lt;a href=&quot;https://en.wikipedia.org/wiki/Internet_Key_Exchange&quot;&gt;Internet Key Exchange&lt;/a&gt;) 均以 DH 算法作为密钥交换算法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-section&quot;&gt;数论知识&lt;/h1&gt;

&lt;p&gt;理解 DH 算法前，先介绍一些必要的数论领域知识，分别是离散对数问题和一个求模公式。&lt;/p&gt;

&lt;h2 id=&quot;id-section-1&quot;&gt;离散对数问题&lt;/h2&gt;

&lt;p&gt;假定 a, p 均是素数，下面两个集合相等，证明过程请参考 &lt;a href=&quot;http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695&quot;&gt;Cryptography and Network Security&lt;/a&gt; 第八章：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ a^1 mod p, a^2 mod p, ..., a^(p-1) mod p } = {1, 2, ... , p-1 }   {} 表示集合
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述式子可概括成以下三点，对于 1 &amp;lt;= x,y &amp;lt;= p - 1，有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;a^x mod p 一定属于 {1, 2, …, p -1 }&lt;/li&gt;
  &lt;li&gt;如果 x != y，则 a^x mod p != a^y mod p&lt;/li&gt;
  &lt;li&gt;对于 1 &amp;lt;= b &amp;lt;= p - 1，一定存在唯一的 1 &amp;lt;= x &amp;lt;= p-1，使得 b = a^x mod p&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第三点在求解上有这么一个特点：已知 x 求 b 非常容易，已知 b 求 x 非常困难，特别当 p 很大时，求解的复杂度非常高，所以它又被称为离散对数问题  (&lt;a href=&quot;https://en.wikipedia.org/wiki/Discrete_logarithm&quot;&gt;Discrete logarithm&lt;/a&gt;)，它是 DH 算法能够安全交换密钥的基础！&lt;/p&gt;

&lt;h2 id=&quot;id-section-2&quot;&gt;求模公式&lt;/h2&gt;

&lt;p&gt;假设 q 为素数，对于正整数 a,x,y，有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(a^x mod p)^y mod p = a^(xy) mod p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;证明如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;令 a^x = mp + n， 其中 m, n 为自然数， 0 &amp;lt;= n &amp;lt; p，则有
C = (a^x mod p)^y mod p
  = ((mp + n) mod p)^y mod p
  = n^y mod p
  = (mp +n)^y mod p
  = a^(xy) mod p
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-deffie-hellman--1&quot;&gt;Deffie-Hellman 算法原理&lt;/h1&gt;

&lt;p&gt;本文参考 &lt;a href=&quot;http://www.amazon.com/Cryptography-Network-Security-Principles-Practice/dp/0133354695&quot;&gt;Cryptography and Network Security&lt;/a&gt; 一书，介绍 DH 算法原理，在掌握上节数论知识的基础上，理解 DH 算法原理非常容易。&lt;/p&gt;

&lt;p&gt;假设 A, B 两方进行通信前需要交换密钥，首先 A, B 共同选取 p 和 a 两个素数，其中 p 和 a 均公开。之后 A 选择一个自然数 Xa，计算出 Ya，Xa 保密，Ya 公开；同理，B 选择 Xb 并计算出 Yb，其中 Xb 保密，Yb 公开。之后 A 用 Yb 和 Xa 计算出密钥 K，而 B 用 Ya 和 Xb 计算密钥 K，流程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-------------------------------------------------------------------+
|                    Global Pulic Elements                          |
|                                                                   |
|       p                               prime number                |
|       a                               prime number, a &amp;lt; p         |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|                    User A Key Generation                          |
|                                                                   |
|       Select private Xa               Xa &amp;lt; p                      |
|       Calculate public Ya             Ya = a^Xa mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|                    User B Key Generation                          |
|                                                                   |
|       Select private Xb               Xb &amp;lt; p                      |
|       Calculate public Yb             Yb = a^Xb mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|               Calculation of Secret Key by User A                 |
|                                                                   |
|       Secret Key K                    K = Yb^Xa mod p             |
+-------------------------------------------------------------------+
+-------------------------------------------------------------------+
|               Calculation of Secret Key by User B                 |
|                                                                   |
|       Secret Key K                    K = Ya^Xb mod p             |
+-------------------------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面证明，A 和 B 计算出来的密钥 K 相同。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;K = Yb^Xa mod p
  = (a^Xb mod p)^Xa mod p
  = a^(Xa * Xb) mod p          根据上述求模公式
  = (a^Xa mod p)^Xb mod p
  = Ya^Xb mod p
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面一共出现了 a, p, Xa, Ya, Xb, Yb, K 共 7 个数，其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;公开的数：a, p, Ya, Yb&lt;/li&gt;
  &lt;li&gt;非公开数：Xa, Xb, K&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常情况下，a 一般为 2 或 5，而 p 的取值非常大，至少几百位，Xa 和 Xb 的取值也非常大，其复杂度至少为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm_for_logarithms&quot;&gt;O(p^0.5)&lt;/a&gt;。对于攻击者来说，已知 Ya，Xa 的求解非常困难，同理 Xb 的求解也很困难，所以攻击者难以求出 K，所以 DH 能够保证通信双方在透明的信道中安全的交换密钥。&lt;a href=&quot;https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#/media/File:Diffie-Hellman_Key_Exchange.svg&quot;&gt;下图&lt;/a&gt;非常形象的描述密钥交换流程：&lt;/p&gt;

&lt;p&gt;                                                &lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/DH%20exchange%20Key.png?imageView2/1/w/310/h/450/q/100&quot; alt=&quot;DH key exchange&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 04 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html</link>
        <guid isPermaLink="true">http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Keystone Google Federation With OpenID</title>
        <description>&lt;hr /&gt;

&lt;p&gt;本文是 Keystone federation identity 系列的第二篇，主要介基于 OpenID Connect 协议搭建 Keystone 和 Google 单点登录的 demo。Federation Identity 的概念、原理以及基于 SAML2 协议的文章请见&lt;a href=&quot;http://wsfdl.com/openstack/2016/01/14/Keystone-Federation-Identity-with-SAML2.html&quot;&gt;第一篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;环境：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux: Ubuntu 14.04 LTS&lt;/li&gt;
  &lt;li&gt;OpenStack: Kilo&lt;/li&gt;
  &lt;li&gt;Identity Provider: Google&lt;/li&gt;
  &lt;li&gt;Federation Protocol： OpenID Connect&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-openid-connect-protocol&quot;&gt;OpenID Connect Protocol&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://openid.net/connect/&quot;&gt;OpenID&lt;/a&gt; 的官网是这样定义 OpenID Connect：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It allows Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以上话语可简单的概括成如下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用于认证 (Authtication) 用户，认证成功后返回用户的基本信息&lt;/li&gt;
  &lt;li&gt;基于 OAuth 2.0 协议，其中 OAuth 是授权(Authorization)相关协议&lt;/li&gt;
  &lt;li&gt;提供了友好的 API，支持 Rest-like 风格&lt;/li&gt;
  &lt;li&gt;支持 web 和 app 等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;即：&lt;/p&gt;

&lt;p&gt;OpenID Connect = OAuth + Identity + Authentication&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-setup-google&quot;&gt;Setup Google&lt;/h1&gt;

&lt;p&gt;首先申请一个域名，并将域名指向 Keystone server，本文在阿里云申请如下域名：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;keystonegoogle.com&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Keystone server 的 IP 为 209.9.108.221，设置如下 DNS 解析：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/keystonegoogledns.png?imageView2/1/w/360/h/80/q/100&quot; alt=&quot;dns&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考&lt;a href=&quot;https://www.youtube.com/watch?v=Rfxy0FKOfgw&quot;&gt;此文&lt;/a&gt;在 &lt;a href=&quot;https://console.developers.google.com/&quot;&gt;console.developers.google.com&lt;/a&gt; 注册一个 application，获取 application 的 Client ID 和 Client Secret 信息，并在 Authorized redirect URIs 中填入重定向 URI，以本文为例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Client ID：388517667150-adc2etk5ohfif5bluber4ho2150pqb3k.apps.googleusercontent.com&lt;/li&gt;
  &lt;li&gt;Client secret：2CnpJ5mm8mfqfoN_6aqd-72A&lt;/li&gt;
  &lt;li&gt;Authorized redirect URIs：www.keystonegoogle.com:5000/v3/auth/OS-FEDERATION/websso/oidc/redirect&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/googleclientsetup.png&quot; alt=&quot;google-openid-client&quot; /&gt;&lt;/p&gt;

&lt;p&gt;      &lt;br /&gt;
      &lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-setup-keystone&quot;&gt;Setup Keystone&lt;/h1&gt;

&lt;p&gt;在某公有云厂商创建一台境外服务器，以便能访问 Google。参考官网文档 &lt;a href=&quot;http://docs.openstack.org/kilo/install-guide/install/apt/content/&quot;&gt;OpenStack Kilo Installation Guide&lt;/a&gt; 安装至第六章 network 即可，因 ubuntu 对 horizon 做了较大改动，所以参考&lt;a href=&quot;http://docs.openstack.org/developer/horizon/topics/install.html&quot;&gt;文档&lt;/a&gt;采用源码安装 horizon。&lt;/p&gt;

&lt;h2 id=&quot;id-configure-keystone&quot;&gt;Configure Keystone&lt;/h2&gt;

&lt;p&gt;下面的安装和配置主要参考 &lt;a href=&quot;http://shop.oreilly.com/product/0636920045960.do&quot;&gt;Identity, Authentication &amp;amp; Access Management in OpenStack&lt;/a&gt;，首先安装 libapache2-mode-auth-openidc：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ apt-get install libjansson4 libhiredis0.10 libcurl3
$ wget https://github.com/pingidentity/mod_auth_openidc/releases/download/v1.8.6/libapache2-mod-auth-openidc_1.8.6-1_amd64.deb
$ dpkg -i libapache2-mod-auth-openidc_1.8.6-1_amd64.deb
$ cp /opt/stack/keystone/etc/sso_callback_template.html /etc/keystone
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新 /etc/keystone/keystone.conf 的如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[auth]
methods = external,password,token,oauth1,oidc
oidc = keystone.auth.plugins.mapped.Mapped

[oidc]
remote_id_attribute = HTTP_OIDC_ISS

[federation]
remote_id_attribute = HTTP_OIDC_ISS
trusted_dashboard = http://keystonegoogle.com/auth/websso/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新 /etc/apache2/sites-available/wsgi-keystone.conf 配置如下，注意到 OIDCClientID，OIDCClientSecret 和 OIDCRedirectURI 依次对应上文 Google Client 的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cat /etc/apache2/sites-available/wsgi-keystone.conf
Listen 5000
Listen 35357

LoadModule auth_openidc_module /usr/lib/apache2/modules/mod_auth_openidc.so

&amp;lt;VirtualHost *:5000&amp;gt;
    WSGIDaemonProcess keystone-public processes=5 threads=1 user=keystone display-name=%{GROUP}
    WSGIProcessGroup keystone-public
    WSGIScriptAlias / /var/www/cgi-bin/keystone/main
    WSGIApplicationGroup %{GLOBAL}
    WSGIPassAuthorization On
    &amp;lt;IfVersion &amp;gt;= 2.4&amp;gt;
      ErrorLogFormat &quot;%{cu}t %M&quot;
    &amp;lt;/IfVersion&amp;gt;
    LogLevel debug
    ErrorLog /var/log/apache2/keystone-error.log
    CustomLog /var/log/apache2/keystone-access.log combined

    OIDCClaimPrefix &quot;OIDC-&quot;
    OIDCResponseType &quot;id_token&quot;
    OIDCScope &quot;openid email profile&quot;
    OIDCProviderMetadataURL &quot;https://accounts.google.com/.well-known/openid-configuration&quot;
    OIDCClientID &quot;388517667150-adc2etk5ohfif5bluber4ho2150pqb3k.apps.googleusercontent.com&quot;
    OIDCClientSecret 2CnpJ5mm8mfqfoN_6aqd-72A
    OIDCCryptoPassphrase openstack
    OIDCRedirectURI &quot;http://keystonegoogle.com:5000/v3/auth/OS-FEDERATION/websso/oidc/redirect&quot;
    &amp;lt;Location ~ &quot;/v3/auth/OS-FEDERATION/websso/oidc&quot;&amp;gt;
      AuthType openid-connect
      Require valid-user
      LogLevel debug
    &amp;lt;/Location&amp;gt;
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:35357&amp;gt;
......
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;id-configure-horizon&quot;&gt;Configure Horizon&lt;/h2&gt;

&lt;p&gt;Horizon 默认不启用 websso，所以需要更新 local_settings.py 以下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;OPENSTACK_KEYSTONE_URL = &quot;http://keystonegoogle.com:5000/v3”
OPENSTACK_API_VERSIONS = {
         &quot;identity&quot;: 3}
WEBSSO_ENABLED = True
WEBSSO_CHOICES = (
    (&quot;credentials&quot;, _(&quot;Keystone Credentials&quot;)),
    (&quot;oidc&quot;, _(&quot;Google Login&quot;)))
WEBSSO_INITIAL_CHOICE = &quot;credentials&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启 Keystone 和 Horizon：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ service apache2 restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;id-create-user-etc&quot;&gt;Create User etc&lt;/h2&gt;

&lt;p&gt;创建 Google 的 Group 和 Project：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ openstack group create google_group
$ openstack project create google_project
$ openstack role add admin --group google_group --project google_project
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 Google Identity Provider：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ curl -g -X POST http://keystonegoogle.com:35357/v3/OS-FEDERATION/identity_providers/google_idp
 -H &quot;Content-Type: application/json&quot; -H &quot;Accept: application/json&quot; -H &quot;X-Auth-Token: $token&quot; -d &#39;{&quot;identity_provider&quot;: {&quot;enabled&quot;: true, &quot;description&quot;: null, &quot;remote_ids&quot;: [&quot;https://accounts.google.com&quot;]}}&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建 mapping 等相关信息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cat google_mapping.json
[
  {
    &quot;local&quot;: [
      {
        &quot;group&quot;: {
          &quot;id&quot;: &quot;a52d06a163f049e29416e20d0e8a12ea&quot;
          }
        }
      ],
    &quot;remote&quot;: [
        {
          &quot;type&quot;: &quot;HTTP_OIDC_ISS&quot;,
          &quot;any_one_of&quot;: [
            &quot;https://accounts.google.com&quot;
            ]
          }
        ]
  }
]

$ openstack mapping create google_mapping --rules google_mapping.json
$ openstack federation protocol create oidc --identity-provider google_idp --mapping google_mapping
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-test&quot;&gt;Test&lt;/h1&gt;

&lt;p&gt;登录 keystonegoogle.com，进入 Login 页面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/Login.png&quot; alt=&quot;login&quot; /&gt;&lt;/p&gt;

&lt;p&gt;选择 Google Login，输入 Google 账户密码即可登录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/keystonegooglegoogleinstance.png&quot; alt=&quot;dashboard&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 01 Feb 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/openstack/2016/02/01/Keystone-Google-Federation--With-OpenID.html</link>
        <guid isPermaLink="true">http://wsfdl.com/openstack/2016/02/01/Keystone-Google-Federation--With-OpenID.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>理解 Oauth 协议</title>
        <description>&lt;hr /&gt;
&lt;p&gt;#Overview&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Authenticate&lt;/li&gt;
  &lt;li&gt;Authorize&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OAuth is an open standard for authorization, commonly used as a way for Internet users to log into third party websites using their Microsoft, Google, Facebook or Twitter accounts without exposing their password.Generally, OAuth provides to clients a ‘secure delegated access’ to server resources on behalf of a resource owner. It specifies a process for resource owners to authorize third-party access to their server resources without sharing their credentials. Designed specifically to work with Hypertext Transfer Protocol (HTTP), OAuth essentially allows access tokens to be issued to third-party clients by an authorization server, with the approval of the resource owner. The third party then uses the access token to access the protected resources hosted by the resource server.[2]&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;standart for authorization&lt;/li&gt;
  &lt;li&gt;secure non-password&lt;/li&gt;
  &lt;li&gt;web, mobile&lt;/li&gt;
  &lt;li&gt;面向 HTTP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;#Role&lt;/p&gt;

&lt;p&gt;resource owner&lt;br /&gt;
      An entity capable of granting access to a protected resource.&lt;br /&gt;
      When the resource owner is a person, it is referred to as an&lt;br /&gt;
      end-user.&lt;/p&gt;

&lt;p&gt;resource server&lt;br /&gt;
      The server hosting the protected resources, capable of accepting&lt;br /&gt;
      and responding to protected resource requests using access tokens.&lt;/p&gt;

&lt;p&gt;client&lt;br /&gt;
      An application making protected resource requests on behalf of the&lt;br /&gt;
      resource owner and with its authorization.  The term “client” does&lt;br /&gt;
      not imply any particular implementation characteristics (e.g.,&lt;br /&gt;
      whether the application executes on a server, a desktop, or other&lt;br /&gt;
      devices).&lt;/p&gt;

&lt;p&gt;authorization server&lt;br /&gt;
      The server issuing access tokens to the client after successfully&lt;br /&gt;
      authenticating the resource owner and obtaining authorization.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;#Flow&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     +--------+                               +---------------+
     |        |--(A)- Authorization Request -&amp;gt;|   Resource    |
     |        |                               |     Owner     |
     |        |&amp;lt;-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant --&amp;gt;| Authorization |
     | Client |                               |     Server    |
     |        |&amp;lt;-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------&amp;gt;|    Resource   |
     |        |                               |     Server    |
     |        |&amp;lt;-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+

                     Figure: Abstract Protocol Flow

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(A)  The client requests authorization from the resource owner.  The&lt;br /&gt;
        authorization request can be made directly to the resource owner&lt;br /&gt;
        (as shown), or preferably indirectly via the authorization&lt;br /&gt;
        server as an intermediary.&lt;/p&gt;

&lt;p&gt;(B)  The client receives an authorization grant, which is a&lt;br /&gt;
        credential representing the resource owner’s authorization,&lt;br /&gt;
        expressed using one of four grant types defined in this&lt;br /&gt;
        specification or using an extension grant type.  The&lt;br /&gt;
        authorization grant type depends on the method used by the&lt;br /&gt;
        client to request authorization and the types supported by the&lt;br /&gt;
        authorization server.&lt;/p&gt;

&lt;p&gt;(C)  The client requests an access token by authenticating with the&lt;br /&gt;
        authorization server and presenting the authorization grant.&lt;/p&gt;

&lt;p&gt;(D)  The authorization server authenticates the client and validates&lt;br /&gt;
        the authorization grant, and if valid, issues an access token.&lt;/p&gt;

&lt;p&gt;(E)  The client requests the protected resource from the resource&lt;br /&gt;
        server and authenticates by presenting the access token.&lt;/p&gt;

&lt;p&gt;(F)  The resource server validates the access token, and if valid,&lt;br /&gt;
        serves the request.&lt;/p&gt;

&lt;p&gt;The preferred method for the client to obtain an authorization grant&lt;br /&gt;
   from the resource owner (depicted in steps (A) and (B)) is to use the&lt;br /&gt;
   authorization server as an intermediary, which is illustrated in&lt;/p&gt;

&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;Protocol Endpoints&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The authorization process utilizes two authorization server endpoints&lt;br /&gt;
   (HTTP resources):&lt;/p&gt;

&lt;p&gt;o  Authorization endpoint - used by the client to obtain&lt;br /&gt;
      authorization from the resource owner via user-agent redirection.&lt;/p&gt;

&lt;p&gt;o  Token endpoint - used by the client to exchange an authorization&lt;br /&gt;
      grant for an access token, typically with client authentication.&lt;/p&gt;

&lt;p&gt;As well as one client endpoint:&lt;/p&gt;

&lt;p&gt;o  Redirection endpoint - used by the authorization server to return&lt;br /&gt;
      responses containing authorization credentials to the client via&lt;br /&gt;
      the resource owner user-agent.&lt;/p&gt;

&lt;p&gt;Not every authorization grant type utilizes both endpoints.&lt;br /&gt;
   Extension grant types MAY define additional endpoints as needed.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-authoriztion-grant&quot;&gt;Authoriztion Grant&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Authorization Code&lt;/li&gt;
  &lt;li&gt;Implicit&lt;/li&gt;
  &lt;li&gt;Resource Owner Password Credentials&lt;/li&gt;
  &lt;li&gt;Client Credentials&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##Authorization Code&lt;/p&gt;

&lt;p&gt;The authorization code is obtained by using an authorization server as an intermediary between the client and resource owner.  Instead of requesting authorization directly from the resource owner, the client directs the resource owner to an authorization server (via its user-agent as defined in [RFC2616]), which in turn directs the resource owner back to the client with the authorization code.&lt;/p&gt;

&lt;p&gt;Before directing the resource owner back to the client with the authorization code, the authorization server authenticates the resource owner and obtains authorization.  Because the resource owner only authenticates with the authorization server, the resource owner’s credentials are never shared with the client.&lt;/p&gt;

&lt;p&gt;The authorization code provides a few important security benefits, such as the ability to authenticate the client, as well as the transmission of the access token directly to the client without passing it through the resource owner’s user-agent and potentially exposing it to others, including the resource owner.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- &amp;amp; Redirection URI ----&amp;gt;|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates ---&amp;gt;|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---&amp;lt;|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |&amp;gt;---(D)-- Authorization Code ---------&#39;      |
     |  Client |          &amp;amp; Redirection URI                  |
     |         |                                             |
     |         |&amp;lt;---(E)----- Access Token -------------------&#39;
     +---------+       (w/ Optional Refresh Token)
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Resource Owner Password Credentials Grant&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
The resource owner password credentials (i.e., username and password) can be used directly as an authorization grant to obtain an access token.  The credentials should only be used when there is a high degree of trust between the resource owner and the client (e.g., the client is part of the device operating system or a highly privileged application), and when other authorization grant types are not available (such as an authorization code).

Even though this grant type requires direct client access to the resource owner credentials, the resource owner credentials are used for a single request and are exchanged for an access token.  This grant type can eliminate the need for the client to store the resource owner credentials for future use, by exchanging the
credentials with a long-lived access token or refresh token.

     +----------+
     | Resource |
     |  Owner   |
     |          |
     +----------+
          v
          |    Resource Owner
         (A) Password Credentials
          |
          v
     +---------+                                  +---------------+
     |         |&amp;gt;--(B)---- Resource Owner -------&amp;gt;|               |
     |         |         Password Credentials     | Authorization |
     | Client  |                                  |     Server    |
     |         |&amp;lt;--(C)---- Access Token ---------&amp;lt;|               |
     |         |    (w/ Optional Refresh Token)   |               |
     +---------+                                  +---------------+

            Figure 5: Resource Owner Password Credentials Flow
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;#Issuing an Access Token&lt;/p&gt;

&lt;p&gt;Access tokens are credentials used to access protected resources.  An access token is a string representing an authorization issued to the&lt;br /&gt;
   client.  The string is usually opaque to the client.  Tokens&lt;br /&gt;
   represent specific scopes and durations of access, granted by the&lt;br /&gt;
   resource owner, and enforced by the resource server and authorization&lt;br /&gt;
   server.&lt;/p&gt;

&lt;p&gt;The token may denote an identifier used to retrieve the authorization&lt;br /&gt;
   information or may self-contain the authorization information in a&lt;br /&gt;
   verifiable manner (i.e., a token string consisting of some data and a&lt;br /&gt;
   signature).  Additional authentication credentials, which are beyond&lt;br /&gt;
   the scope of this specification, may be required in order for the&lt;br /&gt;
   client to use a token.&lt;/p&gt;

&lt;p&gt;The access token provides an abstraction layer, replacing different&lt;br /&gt;
   authorization constructs (e.g., username and password) with a single&lt;br /&gt;
   token understood by the resource server.  This abstraction enables&lt;br /&gt;
   issuing access tokens more restrictive than the authorization grant&lt;br /&gt;
   used to obtain them, as well as removing the resource server’s need&lt;br /&gt;
   to understand a wide range of authentication methods.&lt;/p&gt;

&lt;p&gt;Access tokens can have different formats, structures, and methods of&lt;br /&gt;
   utilization (e.g., cryptographic properties) based on the resource&lt;br /&gt;
   server security requirements.  Access token attributes and the&lt;br /&gt;
   methods used to access protected resources are beyond the scope of&lt;br /&gt;
   this specification and are defined by companion specifications such&lt;br /&gt;
   as&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;#Refreshing an Access Token&lt;/p&gt;

&lt;p&gt;Refresh tokens are credentials used to obtain access tokens.  Refresh&lt;br /&gt;
   tokens are issued to the client by the authorization server and are&lt;br /&gt;
   used to obtain a new access token when the current access token&lt;br /&gt;
   becomes invalid or expires, or to obtain additional access tokens&lt;br /&gt;
   with identical or narrower scope (access tokens may have a shorter&lt;br /&gt;
   lifetime and fewer permissions than authorized by the resource&lt;br /&gt;
   owner).  Issuing a refresh token is optional at the discretion of the&lt;br /&gt;
   authorization server.  If the authorization server issues a refresh&lt;br /&gt;
   token, it is included when issuing an access token (i.e., step (D) in&lt;br /&gt;
   Figure 1).&lt;/p&gt;

&lt;p&gt;A refresh token is a string representing the authorization granted to&lt;br /&gt;
   the client by the resource owner.  The string is usually opaque to&lt;br /&gt;
   the client.  The token denotes an identifier used to retrieve the   authorization information.  Unlike access tokens, refresh tokens are&lt;br /&gt;
   intended for use only with authorization servers and are never sent&lt;br /&gt;
   to resource servers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  +--------+                                           +---------------+
  |        |--(A)------- Authorization Grant ---------&amp;gt;|               |
  |        |                                           |               |
  |        |&amp;lt;-(B)----------- Access Token -------------|               |
  |        |               &amp;amp; Refresh Token             |               |
  |        |                                           |               |
  |        |                            +----------+   |               |
  |        |--(C)---- Access Token ----&amp;gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&amp;lt;-(D)- Protected Resource --| Resource |   | Authorization |
  | Client |                            |  Server  |   |     Server    |
  |        |--(E)---- Access Token ----&amp;gt;|          |   |               |
  |        |                            |          |   |               |
  |        |&amp;lt;-(F)- Invalid Token Error -|          |   |               |
  |        |                            +----------+   |               |
  |        |                                           |               |
  |        |--(G)----------- Refresh Token -----------&amp;gt;|               |
  |        |                                           |               |
  |        |&amp;lt;-(H)----------- Access Token -------------|               |
  +--------+           &amp;amp; Optional Refresh Token        +---------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The flow illustrated in Figure 2 includes the following steps:&lt;/p&gt;

&lt;p&gt;(A)  The client requests an access token by authenticating with the&lt;br /&gt;
        authorization server and presenting an authorization grant.&lt;/p&gt;

&lt;p&gt;(B)  The authorization server authenticates the client and validates&lt;br /&gt;
        the authorization grant, and if valid, issues an access token&lt;br /&gt;
        and a refresh token.&lt;/p&gt;

&lt;p&gt;(C)  The client makes a protected resource request to the resource&lt;br /&gt;
        server by presenting the access token.&lt;/p&gt;

&lt;p&gt;(D)  The resource server validates the access token, and if valid,&lt;br /&gt;
        serves the request.&lt;/p&gt;

&lt;p&gt;(E)  Steps (C) and (D) repeat until the access token expires.  If the&lt;br /&gt;
        client knows the access token expired, it skips to step (G);&lt;br /&gt;
        otherwise, it makes another protected resource request.&lt;/p&gt;

&lt;p&gt;(F)  Since the access token is invalid, the resource server returns&lt;br /&gt;
        an invalid token error.&lt;/p&gt;

&lt;p&gt;(G)  The client requests a new access token by authenticating with&lt;br /&gt;
        the authorization server and presenting the refresh token.  The&lt;br /&gt;
        client authentication requirements are based on the client type&lt;br /&gt;
        and on the authorization server policies.&lt;/p&gt;

&lt;p&gt;(H)  The authorization server authenticates the client and validates&lt;br /&gt;
        the refresh token, and if valid, issues a new access token (and,&lt;br /&gt;
        optionally, a new refresh token).&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/protocol/2016/01/26/Oauth.html</link>
        <guid isPermaLink="true">http://wsfdl.com/protocol/2016/01/26/Oauth.html</guid>
        
        
        <category>protocol</category>
        
      </item>
    
      <item>
        <title>[行摄] 雪后黄山</title>
        <description>&lt;hr /&gt;
&lt;p&gt;   &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;薄海内外，无如徽之黄山，登黄山，天下无山，观止矣！&lt;br /&gt;
                                                                                                           —徐霞客&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;16年元月下旬，南方迎来了十年难逢的暴雪，江浙皖一带白雪皑皑，而黄山更是裹上过膝的雪装。从天气预报得知周五暴雪而周末晴朗，果断起步前往黄山。&lt;/p&gt;

&lt;p&gt;东边日出西边雪，黄山在南方的艳阳里大雪纷飞，当乘索道登上山顶时，宛如在东北冰天雪地的雪原走了一遭，洁白的栈道，棉花糖般的雪松，交错有致的琼枝，蔚蓝的天空和冬天里的艳阳，给险峻的黄山平添了几份童话的色彩。忽如一夜春风来，千树万树梨花开，暮雪千山妖娆，玉树琼枝醉人。傍晚的西海大峡谷显得更加温馨，日暮的晚霞，夕阳映雪，日照金松，一切显得如此祥和宁静。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P1. 始信峰远眺&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P1_xhs.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P2. 云谷远眺&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P2_xhs.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P3. 云谷远眺&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P3_xhs.jpg?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P4. 雪松琼枝&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P4_xhs.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P5. 暮色雪松&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P5_xhs.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P6. 日落西海&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P6_xhs.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;    &lt;br /&gt;
    &lt;/p&gt;

&lt;p&gt;P7. 夕阳映雪&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/P7_xhs.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p7&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/photos/2016/01/24/%E9%9B%AA%E5%90%8E%E9%BB%84%E5%B1%B1.html</link>
        <guid isPermaLink="true">http://wsfdl.com/photos/2016/01/24/%E9%9B%AA%E5%90%8E%E9%BB%84%E5%B1%B1.html</guid>
        
        
        <category>photos</category>
        
      </item>
    
      <item>
        <title>Keystone Federation Identity With SAML2</title>
        <description>&lt;hr /&gt;

&lt;p&gt;Keystone federation identity 涉及很多概念，安装配置复杂，官网的文档又不够清晰，下面 4 篇文章在安装配置方面阐述的非常详细。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.rodrigods.com/it-is-time-to-play-with-keystone-to-keystone-federation-in-kilo/&quot;&gt;Configure Keystone to Keystone Federation&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bigjools.wordpress.com/2015/05/22/saml-federation-with-openstack/&quot;&gt;Configure Keystone to Testshib Federation with SAML&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://bigjools.wordpress.com/2015/04/27/federated-openstack-logins-using-kerberos/&quot;&gt;Configure Keystone federation with Kerberos&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zenodo.org/record/11982/files/CERN_openlab_Luca_Tartarini.pdf&quot;&gt;Configure Keystone federation with multi-IDP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-federation-identity-&quot;&gt;Federation Identity 简介&lt;/h1&gt;

&lt;p&gt;关于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Federated_identity&quot;&gt;federation identity&lt;/a&gt;，维基百科的定义如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A federated identity is the means of linking a person’s electronic identity and attributes, stored across multiple distinct identity management systems(IDM).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在多个认证管理系统互相信任的基础上，federation identity 允许多个认证管理系统联邦认证各个系统的用户身份。它最重要的一个功能就是实现单点登录(&lt;a href=&quot;https://en.wikipedia.org/wiki/Single_sign-on&quot;&gt;Single Sign On&lt;/a&gt;)，用户仅需认证一次，便可访问这些互相授信的资源。比如 A 公司员工需使用 AWS 公有云，出于安全考虑，不希望在 AWS 的 IAM 创建员工账户信息，通过 federation identity 打通二者之间的用户授权和认证，A 公司员工只需在本公司完成身份认证即可访问 AWS 资源。我们把 A 公司称之为 Identity Provider(IDP), AWS 称之为 Service Provider(SP)。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Service Provider: 服务提供方，它只提供服务，依赖 Identity Provider 认证用户身份&lt;/li&gt;
  &lt;li&gt;Identity Provider: 断言(assertion)方，用于认证用户身份&lt;/li&gt;
  &lt;li&gt;Assertion Protocol: 认证(断言)协议，Service Provider 和 Identity Provider 完成认证用户身份所用的协议，常用有 SAML, OpenID, Oauth 等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以 SAML 协议为例，典型的&lt;a href=&quot;http://www.searchsoa.com.cn/showcontent_1604.htm&quot;&gt;认证流程&lt;/a&gt;分为 &lt;a href=&quot;https://en.wikipedia.org/wiki/SAML_2.0#HTTP_Redirect_Binding&quot;&gt;Redirect Bindings&lt;/a&gt; 和 &lt;a href=&quot;https://en.wikipedia.org/wiki/SAML_2.0#HTTP_Artifact_Binding&quot;&gt;Artifact/POST Bindings&lt;/a&gt; 两种。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/Redirect%20Binding.png?imageView2/1/w/600/h/400/q/100&quot; alt=&quot;Redirect Bindings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/artifact%20binding.png?imageView2/1/w/600/h/400/q/100&quot; alt=&quot;Artifact Bindings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Federation identity 具有以下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持 SSO 单点登录&lt;/li&gt;
  &lt;li&gt;避免向 Service Provider 暴露用户信息，提高安全性&lt;/li&gt;
  &lt;li&gt;避免用户注册多个账号，增加用户负担&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-keystone-federation-&quot;&gt;Keystone Federation 的原理&lt;/h1&gt;

&lt;p&gt;Federation identity 为 hybrid cloud 在用户管理层面提供了良好的解决方案。Keystone 从 Icehouse 开始逐步增加 federation identity 的功能，Icehouse 支持 Keystone 作为 Service Provider，Juno 版本新增了 Identity Provider，支持 SAML 和 OpenID 两种认证协议。OpenStack 作为云服务的解决方案，对外提供计算、存储和网络等服务，多数场景下 Keystone 常常作为服务端，对接其它的 Identity Provider，所以本节着重阐述 Service Provider 的原理和流程。首先先介绍 3 类重要的 &lt;a href=&quot;https://specs.openstack.org/openstack/keystone-specs/api/v3/identity-api-v3-os-federation-ext.html&quot;&gt;API&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Identity Provider API: /OS-FEDERATION/identity_providers         &lt;br /&gt;
管理 Keystone 信任的 Identity Providers。&lt;/li&gt;
  &lt;li&gt;Protocol API: /OS-FEDERATION/identity_providers/{idp_id}/protocols   &lt;br /&gt;
管理 Keystone 和某个 Identity Provider 之间认证的协议，通常为 oidc(OpenID) 或 saml2(SAML)。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mapping API: /OS-FEDERATION/mappings    &lt;br /&gt;
管理 Identity Provider 里的用户和 Keystone 里的用户之间的映射规则，通过该 API，管理员可以管理 IDP 中用户访问 Service 的权限。比如 IDP 有用户 A，B，通过配置 mapping rule，可以允许 A 有权限而 B 无权限访问。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/federation%20service%20provider.png?imageView2/1/w/500/h/400/q/100&quot; alt=&quot;Keystone Federation&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了支持 Service Provider，Keystone 必须运行在 Apache HTTPD 上，mod-shibboleth 作为 apache plugin 支持 SAML 认证协议，完成了 Keystone 和 IDP 之间用户的身份认证，&lt;a href=&quot;http://shop.oreilly.com/product/0636920045960.do&quot;&gt;流程&lt;/a&gt;如下。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户访问 /OS-FEDERATION/identity_providers/{identity_provider}/protocols/{protocol}/auth，Apache 捕获该 URL 并触发 mod-shibboleth 重定向至外部的 Identity Provider。&lt;/li&gt;
  &lt;li&gt;外部的 Identity Provider 认证用户的身份并把用户的某些身份信息返回给 Apache，Apache 再把信息传给 Keystone。&lt;/li&gt;
  &lt;li&gt;Keystone 根据 mapping rule 把判断用户是否有访问权限，如果有访问权限，返回一个 unscoped token。用户可拿 unscoped token 查看可用的 project 并生成 scoped token，进而访问 OpenStack 的 API。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-configure-keystone-as-a-service-provider&quot;&gt;Configure Keystone as a Service Provider&lt;/h1&gt;

&lt;p&gt;本节开始介绍如何安装配置 Keystone to Keystone Federation，重点参考了 &lt;a href=&quot;http://blog.rodrigods.com/it-is-time-to-play-with-keystone-to-keystone-federation-in-kilo/&quot;&gt;it-is-time-to-play-with-keystone-to-keystone-federation-in-kilo&lt;/a&gt;(原文存在 2 处配置错误，本文已给予纠正)。 我们有两个服务器，分别作为 SP 和 IDP，二者均需按照&lt;a href=&quot;http://docs.openstack.org/kilo/install-guide/install/apt/content/ch_keystone.html&quot;&gt;官网的手册&lt;/a&gt;安装 Keystone。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux: Ubuntu 14.04 LTS&lt;/li&gt;
  &lt;li&gt;OpenStack: Kilo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更新 keystone.conf 如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[auth]
methods = external,password,token,oauth1,saml2
saml2 = keystone.auth.plugins.mapped.Mapped 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache 新增如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;Listen 5000
Listen 35357

&amp;lt;VirtualHost *:5000&amp;gt;
    WSGIScriptAliasMatch ^(/v3/OS-FEDERATION/identity_providers/.*?/protocols/.*?/auth)$ /var/www/cgi-bin/keystone/main/$1
     ......
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:35357&amp;gt;
    WSGIScriptAliasMatch ^(/v3/OS-FEDERATION/identity_providers/.*?/protocols/.*?/auth)$ /var/www/cgi-bin/keystone/admin/$1
      ......
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;Location /Shibboleth.sso&amp;gt;
    SetHandler shib
&amp;lt;/Location&amp;gt;

&amp;lt;LocationMatch /v3/OS-FEDERATION/identity_providers/.*?/protocols/saml2/auth&amp;gt;
    ShibRequestSetting requireSession 1
    AuthType shibboleth
    ShibExportAssertion Off
    Require valid-user
&amp;lt;/LocationMatch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 Shibboleth：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ apt-get install libapache2-mod-shib2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新 /etc/shibboleth/attribute-map.xml 的以下配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Attribute name=&quot;openstack_user&quot; id=&quot;openstack_user&quot;/&amp;gt;  
&amp;lt;Attribute name=&quot;openstack_roles&quot; id=&quot;openstack_roles&quot;/&amp;gt;  
&amp;lt;Attribute name=&quot;openstack_project&quot; id=&quot;openstack_project&quot;/&amp;gt; 
&amp;lt;Attribute name=&quot;openstack_user_domain&quot; id=&quot;openstack_user_domain&quot;/&amp;gt;  
&amp;lt;Attribute name=&quot;openstack_project_domain&quot; id=&quot;openstack_project_domain&quot;/&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新 /etc/shibboleth/shibboleth2.xml 的以下配置项：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;SSO entityID=&quot;http://idp:5000/v3/OS-FEDERATION/saml2/idp&quot;&amp;gt;  
    SAML2 SAML1
&amp;lt;/SSO&amp;gt;

&amp;lt;MetadataProvider type=&quot;XML&quot; uri=&quot;http://idp:5000/v3/OS-FEDERATION/saml2/metadata&quot;/&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动 shibboleth 并重启 apache：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ shib-keygen  
$ service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看 shibboleth 是否正常运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ a2enmod shib2
Module shib2 already enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-configure-keystone-as-an-identity-provider&quot;&gt;Configure Keystone as an Identity Provider&lt;/h1&gt;

&lt;p&gt;安装 xmlsec1 和 pysaml2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ apt-get install xmlsec1  
$ pip install pysaml2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新 keystone.conf 的如下配置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[saml]
certfile=/etc/keystone/ssl/certs/ca.pem  
keyfile=/etc/keystone/ssl/private/cakey.pem  
idp_entity_id=http://idp:5000/v3/OS-FEDERATION/saml2/idp  
idp_sso_endpoint=http://idp:5000/v3/OS-FEDERATION/saml2/sso  
idp_metadata_path=/etc/keystone/keystone_idp_metadata.xml  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成 DIP 的 metadata 并重启 apache HTTPD：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ keystone-manage saml_idp_metadata &amp;gt; /etc/keystone/keystone_idp_metadata.xml
service apache2 restart
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-test-keystone-to-keystone-federation&quot;&gt;Test Keystone to Keystone federation&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;在 Service Provider 端执行以下脚本，创建 domain, group, mapping, idp, protocol 等。其中 idp 指向另外一个作为 Identity Provider 的 Keystone，protocol 采用了 saml2 协议，mapping 的规则为只要 IDP 中名为 bob 或者 acme 的用户都可通过认证，并且映射到 Service 端的 federated_user 用户上。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import os

from keystoneclient import session as ksc_session
from keystoneclient.auth.identity import v3
from keystoneclient.v3 import client as keystone_v3

try:
    # Used for creating the ADMIN user
    OS_PASSWORD = &#39;123456&#39;
    OS_USERNAME = &#39;admin&#39;
    # This will vary according to the entity:
    # the IdP or the SP
    OS_AUTH_URL = &#39;http://sp:35357/v3&#39;
    OS_PROJECT_NAME = &#39;admin&#39;
    OS_DOMAIN_NAME = &#39;default&#39;
except KeyError as e:
    raise SystemExit(&#39;%s environment variable not set.&#39; % e)

def client_for_admin_user():
    auth = v3.Password(auth_url=OS_AUTH_URL,
                       username=OS_USERNAME,
                       password=OS_PASSWORD,
                       user_domain_name=OS_DOMAIN_NAME,
                       project_name=OS_PROJECT_NAME,
                       project_domain_name=OS_DOMAIN_NAME)
    session = ksc_session.Session(auth=auth)
    return keystone_v3.Client(session=session)

# Used to execute all admin actions
client = client_for_admin_user()

def create_domain(client, name):
    try:
         d = client.domains.create(name=name)
    except:
         d = client.domains.find(name=name)
    return d


def create_group(client, name, domain):
    try:
         g = client.groups.create(name=name, domain=domain)
    except:
         g = client.groups.find(name=name)
    return g


def create_role(client, name):
    try:
        r = client.roles.create(name=name)
    except:
        r = client.roles.find(name=name)
    return r


print(&#39;\nCreating domain1&#39;)
domain1 = create_domain(client, &#39;domain1&#39;)

print(&#39;\nCreating group1&#39;)
group1 = create_group(client, &#39;group1&#39;, domain1)

print(&#39;\nCreating role Member&#39;)
role1 = create_role(client, &#39;Member&#39;)

print(&#39;\nGrant role Member to group1 in domain1&#39;)
client.roles.grant(role1, group=group1, domain=domain1)

print(&#39;\nList group1 role assignments&#39;)
client.role_assignments.list(group=group1)

def create_mapping(client, mapping_id, rules):
    try:
        m = client.federation.mappings.create(
            mapping_id=mapping_id, rules=rules)
    except:
        m = client.federation.mappings.find(
            mapping_id=mapping_id)
    return m

print(&#39;\nCreating mapping&#39;)
rules = [
{
    &quot;local&quot;: [
        {
            &quot;user&quot;: {
                &quot;name&quot;: &quot;federated_user&quot;
            },
            &quot;group&quot;: {
                &quot;id&quot;: group1.id
            }
        }
    ],
    &quot;remote&quot;: [
        {
            &quot;type&quot;: &quot;openstack_user&quot;,
            &quot;any_one_of&quot;: [
                &quot;bob&quot;,
                &quot;acme&quot;
            ]
        }
    ]
}
]

mapping1 = create_mapping(client, mapping_id=&#39;keystone-idp-mapping&#39;, rules=rules)


def create_idp(client, id, remote_id):
    idp_ref = {&#39;id&#39;: id,
               &#39;remote_ids&#39;: [remote_id],
               &#39;enabled&#39;: True}
    try:
        i = client.federation.identity_providers.create(**idp_ref)
    except:
        i = client.federation.identity_providers.find(id=id)
    return i

def create_protocol(client, protocol_id, idp, mapping):
    try:
        p = client.federation.protocols.create(protocol_id=protocol_id,
                                               identity_provider=idp,
                                               mapping=mapping)
    except:
        p = client.federation.protocols.find(protocol_id=protocol_id)
    return p


print(&#39;\nRegister keystone-idp&#39;)
idp1 = create_idp(client, id=&#39;keystone-idp&#39;,
                  remote_id=&#39;http://idp:5000/v3/OS-FEDERATION/saml2/idp&#39;)

print(&#39;\nRegister protocol&#39;)
protocol1 = create_protocol(client, protocol_id=&#39;saml2&#39;, idp=idp1,
                            mapping=mapping1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 IDP 端执行以下脚本，用户 bob 获得一个 unscoped token，可拿该 token 向 SP 获取 scope token 后访问 Service 端的资源。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import json
import os

import requests

from keystoneclient import session as ksc_session
from keystoneclient.auth.identity import v3
from keystoneclient.v3 import client as keystone_v3


class K2KClient(object):
    def __init__(self):
        self.sp_id = &#39;keystone-sp&#39;
        self.auth_url = &#39;http://idp:35357/v3&#39;
        self.project_id = &#39;582df27a0db14149a6da375b31fce3df&#39;
        self.username = &#39;bob&#39;
        self.password = &#39;123456&#39;
        self.domain_id = &#39;default&#39;

    def v3_authenticate(self):
        auth = v3.Password(auth_url=self.auth_url,
                           username=self.username,
                           password=self.password,
                           user_domain_id=self.domain_id,
                           project_id=self.project_id)
        self.session = ksc_session.Session(auth=auth, verify=False)
        self.session.auth.get_auth_ref(self.session)
        self.token = self.session.auth.get_token(self.session)
    def _generate_token_json(self):
        return {
            &quot;auth&quot;: {
                &quot;identity&quot;: {
                    &quot;methods&quot;: [
                        &quot;token&quot;
                    ],
                    &quot;token&quot;: {
                        &quot;id&quot;: self.token
                    }
                },
                &quot;scope&quot;: {
                    &quot;service_provider&quot;: {
                        &quot;id&quot;: self.sp_id
                    }
                }
            }
        }

    def _check_response(self, response):
        if not response.ok:
            raise Exception(&quot;Something went wrong, %s&quot; % response.__dict__)

    def get_saml2_ecp_assertion(self):
        token = json.dumps(self._generate_token_json())
        url = self.auth_url + &#39;/auth/OS-FEDERATION/saml2/ecp&#39;
        r = self.session.post(url=url, data=token, verify=False)
        self._check_response(r)
        self.assertion = str(r.text)

    def _get_sp(self):
        url = self.auth_url + &#39;/OS-FEDERATION/service_providers/&#39; + self.sp_id
        r = self.session.get(url=url, verify=False)
        self._check_response(r)
        sp = json.loads(r.text)[u&#39;service_provider&#39;]
        return sp

    def _handle_http_302_ecp_redirect(self, response, location, **kwargs):
        return self.session.get(location, authenticated=False, **kwargs)

    def exchange_assertion(self):
        &quot;&quot;&quot;Send assertion to a Keystone SP and get token.&quot;&quot;&quot;
        sp = self._get_sp()

        r = self.session.post(
            sp[u&#39;sp_url&#39;],
            headers={&#39;Content-Type&#39;: &#39;application/vnd.paos+xml&#39;},
            data=self.assertion,
            authenticated=False,
            redirect=False)

        self._check_response(r)

        r = self._handle_http_302_ecp_redirect(r, sp[u&#39;auth_url&#39;],
                                               headers={&#39;Content-Type&#39;:
                                               &#39;application/vnd.paos+xml&#39;})
        self.fed_token_id = r.headers[&#39;X-Subject-Token&#39;]
        self.fed_token = r.text

    def list_federated_projects(self):
        url = &#39;http://sp:5000/v3/OS-FEDERATION/projects&#39;
        headers = {&#39;X-Auth-Token&#39;: self.fed_token_id}
        r = requests.get(url=url, headers=headers)
        self._check_response(r)
        return json.loads(str(r.text))

    def _get_scoped_token_json(self, project_id):
        return {
            &quot;auth&quot;: {
                &quot;identity&quot;: {
                    &quot;methods&quot;: [
                        &quot;token&quot;
                    ],
                    &quot;token&quot;: {
                        &quot;id&quot;: self.fed_token_id
                    }
                },
                &quot;scope&quot;: {
                    &quot;project&quot;: {
                        &quot;id&quot;: project_id
                    }
                }
            }
        }

    def scope_token(self, project_id):
        # project_id can be select from the list in the previous step
        token = json.dumps(self._get_scoped_token_json(project_id))
        url = &#39;http://sp:5000/v3/auth/tokens&#39;
        headers = {&#39;X-Auth-Token&#39;: self.fed_token_id,
                   &#39;Content-Type&#39;: &#39;application/json&#39;}
        r = requests.post(url=url, headers=headers, data=token,
                          verify=False)
        self._check_response(r)
        self.scoped_token_id = r.headers[&#39;X-Subject-Token&#39;]
        self.scoped_token = str(r.text)


def main():
    client = K2KClient()
    client.v3_authenticate()
    client.get_saml2_ecp_assertion()
    print(&#39;ECP wrapped SAML assertion: %s&#39; % client.assertion)
    client.exchange_assertion()
    print(&#39;Unscoped token id: %s&#39; % client.fed_token_id)
    
    # If you want to get a scope token, please ensure federated_user has a project
    # and uncommen below codes.
    &#39;&#39;&#39;
    projects = client.list_federated_projects()
    print(&#39;Federated projects: %s&#39; % projects[&#39;projects&#39;])
    project_id = projects[&#39;projects&#39;][0][&#39;id&#39;]
    project_name = projects[&#39;projects&#39;][0][&#39;name&#39;]
    client.scope_token(project_id)
    print(&#39;Scoped token of &#39; + project_name + &#39; : &#39; + client.scoped_token_id)
    &#39;&#39;&#39;


if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-reference&quot;&gt;Reference&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;https://developer.rackspace.com/blog/keystone-to-keystone-federation-with-openstack-ansible/&lt;/li&gt;
  &lt;li&gt;https://specs.openstack.org/openstack/keystone-specs/api/v3/identity-api-v3-os-federation-ext.html&lt;/li&gt;
  &lt;li&gt;http://blog.rodrigods.com/it-is-time-to-play-with-keystone-to-keystone-federation-in-kilo/&lt;/li&gt;
  &lt;li&gt;https://bigjools.wordpress.com/2015/05/22/saml-federation-with-openstack/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 14 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/openstack/2016/01/14/Keystone-Federation-Identity-with-SAML2.html</link>
        <guid isPermaLink="true">http://wsfdl.com/openstack/2016/01/14/Keystone-Federation-Identity-with-SAML2.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>Keystone 集成 LDAP</title>
        <description>&lt;hr /&gt;

&lt;p&gt;得益于 Keystone 优良的架构，它允许 Service 适配多种 Backend。Keystone 目前有 Identity, Resource, Assigment, Token, Policy, Catatlog 等 service，在 K 版本中，Identity, Resource, Assigment 都支持 LDAP 作为其 Backend，但是因为 Resource 和 Assigment 中的某些属性在 LDAP 并不能很好的支持，因此从 M 版本后，只有 Idendity 支持 LDAP 作为 Backend。本文的例子也仅将 Identity 的数据存储在 LDAP 中，其它 Services 的数据依旧存储在 SQL 里。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Identity: User and Group&lt;/li&gt;
  &lt;li&gt;Resource: Project and Domain&lt;/li&gt;
  &lt;li&gt;Assigment: Role and Role Assigment&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/keystone%20service%20and%20backend.png?imageView2/1/w/1300/q/100&quot; alt=&quot;Services and Backends&quot; /&gt;&lt;/p&gt;

&lt;p&gt;基本配置如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux: Ubuntu 14.04 LTS&lt;/li&gt;
  &lt;li&gt;OpenStack: Kilo&lt;/li&gt;
  &lt;li&gt;LDAP: slapd 2.4.31&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LDAP 的 DN(Distinguished Names) 默认由主机域名生成，本地的 DNS 设置如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cat /etc/hosts
10.10.1.100    keystone.com
127.0.0.1   localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;

&lt;h1 id=&quot;id-install-ldap&quot;&gt;Install LDAP&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ apt-get install slapd ldap-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后可通过以下命令和步骤完成 LDAP 的基本配置：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ dpkg-reconfigure slapd

* Omit OpenLDAP server configuration? No

* DNS domain name?  keystone.com

* Organization name?  admin

* Administrator password? YourPassword

* Use the password you configured during installation, or choose another one
  Database backend to use? HDB

* Remove the database when slapd is purged? No

* Move old database? Yes

* Allow LDAPv2 protocol? No
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-configure-ldap&quot;&gt;Configure LDAP&lt;/h1&gt;

&lt;p&gt;由于 LDAP 的用户属性和 Keystone 默认的用户属性有所差异，所以 LDAP 需生成与 Keystone 中的 User 和 Group 相匹配的对象，可通过以下脚本(add_user_group.ldif)添加该对象，并生成 demo 和 admin 两个用户。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Users
dn: ou=users,dc=keystone,dc=com
ou: users
objectClass: organizationalUnit

# Group
dn: ou=groups,dc=keystone,dc=com
objectClass: organizationalUnit
ou: groups

# demo user
dn: cn=demo,ou=users,dc=keystone,dc=com
cn: demo
displayName: demo
givenName: demo
mail: demo@example.com
objectClass: inetOrgPerson
objectClass: top
sn: demo
uid: demo
userPassword: 123456

# admin user
dn: cn=admin,ou=users,dc=keystone,dc=com
cn: admin
displayName: admin
givenName: admin
mail: admin@example.com
objectClass: inetOrgPerson
objectClass: top
sn: admin
uid: admin
userPassword: 123456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由以下命令把上述配置文件内容更新至 LDAP：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ldapadd -x -W -D &quot;cn=admin,dc=example,dc=com&quot; -f add_user_group.ldif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keystone 的配置文件如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[identity]
driver = keystone.identity.backends.ldap.Identity

[assignment]
driver = keystone.assignment.backends.sql.Assignment

[ldap]
# LDAP 服务器地址，tree_dn 目录下管理员的账号和密码等
url = ldap://keystone.com              
query_scope = sub
user = &quot;cn=admin,dc=keystone,dc=com&quot; 
password = 123456
tree_dn = &quot;dc=keystone,dc=com&quot;

# 以下配置定义 Keystone 和 LDAP 二者的属性的 mapping 关系。
user_tree_dn = &quot;ou=users,dc=keystone,dc=com&quot;  
user_objectclass = inetOrgPerson
user_id_attribute = cn
user_name_attribute = cn
user_mail_attribute = mail
user_pass_attribute = userPassword
user_enabled_attribute = enabled

group_tree_dn = &quot;ou=groups,dc=keystone,dc=com&quot;
group_objectclass = groupOfUniqueNames
group_id_attribute = cn
group_name_attribute = cn
group_member_attribute = uniquemember
group_desc_attribute = description

user_allow_create = true
user_allow_update = true
user_allow_delete = true

group_allow_create = true
group_allow_update = true
group_allow_delete = true
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-test&quot;&gt;Test&lt;/h1&gt;

&lt;p&gt;用 admin_token 创建 project 和 role，并赋予 demo 和 admin 用户在 project 中的 role 后，即可使用该用户获得 scope token 访问 Keystone 的 API。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ openstack user list
+--------------------+--------------------+
| ID                 | Name               |
+--------------------+--------------------+
| demo               | demo               |
| admin              | admin              |
+--------------------+--------------------+

$ openstack user show demo
+-----------+------------------+
| Field     | Value            |
+-----------+------------------+
| domain_id | default          |
| email     | demo@example.com |
| id        | demo             |
| name      | demo             |
+-----------+------------------+

$ openstack user create hello --password 123456
+-----------+----------------------------------+
| Field     | Value                            |
+-----------+----------------------------------+
| domain_id | default                          |
| enabled   | True                             |
| id        | hello                            |
| name      | hello                            |
+-----------+----------------------------------+

$ openstack project create test_project
+-------------+----------------------------------+
| Field       | Value                            |
+-------------+----------------------------------+
| description |                                  |
| domain_id   | default                          |
| enabled     | True                             |
| id          | cbdf05b17cf54587b3b58a11f49252e7 |
| name        | test_project                     |
+-------------+----------------------------------+
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 13 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/openstack/2016/01/13/Keystone%E9%9B%86%E6%88%90LDAP.html</link>
        <guid isPermaLink="true">http://wsfdl.com/openstack/2016/01/13/Keystone%E9%9B%86%E6%88%90LDAP.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
      <item>
        <title>[行摄] 上海武康路</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%AD%A6%E5%BA%B7%E8%B7%AF_(%E4%B8%8A%E6%B5%B7)&quot;&gt;武康路&lt;/a&gt;原名福开森路(Route Ferguson)，北起华山路，南接淮海中路，由法租界公董局修筑于1907年，后于汪精卫政府时期更名为武康路。这里住过次吒风云政要陈立夫等、陈丕显等人，也被商业大亨严裕棠等所青睐，更留下昔日红颜秦怡、王文娟等往事，还有巴金深夜耕耘的佳作。&lt;/p&gt;

&lt;p&gt;原以为上海除了高楼还是高楼，当看到两旁坐落着民国时期建造的花园洋房与历史公寓时，欣喜之情情不自禁流露而出。16年的元旦是个天朗气清的冬日，午后暖阳甚是令人心旷神怡。据说从 13 年起，武康路不在人为清扫落叶，深秋的法桐路下，值得再踏叶游览一次。&lt;/p&gt;

&lt;p&gt; &lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
P1. 饰品店&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/IMG_3024.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p1&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P2. 丁香别墅&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/IMG_3074.JPG?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p2&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P3. 武原路&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/IMG_2971.JPG?imageView2/1/w/533/h/800/q/100&quot; alt=&quot;p3&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P4. 咖啡馆&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/IMG_2996.JPG?imageView2/1/w/533/h/800/q/100&quot; alt=&quot;p4&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/photos/2016/01/03/%E4%B8%8A%E6%B5%B7%E6%AD%A6%E5%BA%B7%E8%B7%AF.html</link>
        <guid isPermaLink="true">http://wsfdl.com/photos/2016/01/03/%E4%B8%8A%E6%B5%B7%E6%AD%A6%E5%BA%B7%E8%B7%AF.html</guid>
        
        
        <category>photos</category>
        
      </item>
    
      <item>
        <title>理解 Keystone 的四种 Token</title>
        <description>&lt;hr /&gt;

&lt;h1 id=&quot;id-token-&quot;&gt;Token 是什么&lt;/h1&gt;

&lt;p&gt;通俗的讲，token 是用户的一种凭证，需拿正确的用户名/密码向 Keystone 申请才能得到。如果用户每次都采用用户名/密码访问 OpenStack API，容易泄露用户信息，带来安全隐患。所以 OpenStack 要求用户访问其 API 前，必须先获取 token，然后用 token 作为用户凭据访问 OpenStack API。&lt;br /&gt;
&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/uuid.png&quot; alt=&quot;P1&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-token--1&quot;&gt;四种 Token 的由来&lt;/h1&gt;

&lt;p&gt;D 版本时，仅有 UUID 类型的 Token，UUID token 简单易用，却容易给 Keystone 带来性能问题，从图一的步骤 4 可看出，每当 OpenStack API 收到用户请求，都需要向 Keystone 验证该 token 是否有效。随着集群规模的扩大，Keystone 需处理大量验证 token 的请求，在高并发下容易出现性能问题。&lt;/p&gt;

&lt;p&gt;于是 PKI(&lt;a href=&quot;https://wiki.openstack.org/wiki/PKI&quot;&gt;Public Key Infrastructrue&lt;/a&gt;) token 在 G 版本运用而生，和 UUID 相比，PKI token 携带更多用户信息的同时还附上了数字签名，以支持本地认证，从而避免了步骤 4。因为 PKI token 携带了更多的信息，这些信息就包括 service catalog，随着 OpenStack 的 Region 数增多，service catalog 携带的 endpoint 数量越多，PKI token 也相应增大，很容易超出 HTTP Server 允许的最大 HTTP Header(默认为 8 KB)，导致 HTTP 请求失败。&lt;/p&gt;

&lt;p&gt;顾名思义，&lt;a href=&quot;https://blueprints.launchpad.net/keystone/+spec/compress-tokens&quot;&gt;PKIZ token&lt;/a&gt; 就是 PKI token 的压缩版，但压缩效果有限，无法良好的处理 token size 过大问题。&lt;/p&gt;

&lt;p&gt;前三种 token 都会持久性存于数据库，与日俱增积累的大量 token 引起数据库性能下降，所以用户需经常清理数据库的 token。为了避免该问题，社区提出了 Fernet token，它携带了少量的用户信息，大小约为 255 Byte，采用了对称加密，无需存于数据库中。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-uuid&quot;&gt;UUID&lt;/h1&gt;

&lt;p&gt;UUID token 是长度固定为 32 Byte 的随机字符串，由 uuid.uuid4().hex 生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def _get_token_id(self, token_data):
    return uuid.uuid4().hex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是因 UUID token 不携带其它信息，OpenStack API 收到该 token 后，既不能判断该 token 是否有效，更无法得知该 token 携带的用户信息，所以需经图一步骤 4 向 Keystone 校验 token，并获用户相关的信息。其样例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;144d8a99a42447379ac37f78bf0ef608
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;UUID token 简单美观，不携带其它信息，因此 Keystone 必须实现 token 的存储和认证，随着集群的规模增大，Keystone 将成为性能瓶颈。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-pki&quot;&gt;PKI&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/pki.png&quot; alt=&quot;P2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在阐述 PKI（Public Key Infrastruction） token 前，让我们简单的回顾&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86&quot;&gt;公开密钥加密(public-key cryptography)&lt;/a&gt;和&lt;a href=&quot;http://www.youdzone.com/signature.html&quot;&gt;数字签名&lt;/a&gt;。公开密钥加密，也称为非对称加密(asymmetric cryptography，加密密钥和解密密钥不相同)，在这种密码学方法中，需要一对密钥，分别为公钥(Public Key)和私钥(Private Key)，公钥是公开的，私钥是非公开的，需用户妥善保管。如果把加密和解密的流程当做函数 C(x) 和 D(x)，P 和 S 分别代表公钥和私钥，对明文 A 和密文 B 而言，数学的角度上有以下公式：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;B = C(A, S)  &lt;br /&gt;
A = D(B, P)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中加密函数 C(x), 解密函数 D(x) 以及公钥 P 均是公开的。采用公钥加密的密文只能用私钥解密，采用私钥加密的密文只能用公钥解密。非对称加密广泛运用在安全领域，诸如常见的 HTTPS，SSH 登录等。&lt;/p&gt;

&lt;p&gt;数字签名又称为公钥数字签名，首先采用 Hash 函数对消息生成摘要，摘要经私钥加密后称为数字签名。接收方用公钥解密该数字签名，并与接收消息生成的摘要做对比，如果二者一致，便可以确认该消息的完整性和真实性。&lt;/p&gt;

&lt;p&gt;PKI 的本质就是基于数字签名，Keystone 用私钥对 token 进行数字签名，各个 API server 用公钥在本地验证该 token。相关代码简化如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def _get_token_id(self, token_data):
    try:
        token_json = jsonutils.dumps(token_data, cls=utils.PKIEncoder)
        token_id = str(cms.cms_sign_token(token_json,
                                          CONF.signing.certfile,
                                          CONF.signing.keyfile))
        return token_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 cms.cms_sign_token 调用 openssl cms –sign 对 token_data 进行签名，token_data 的样式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &quot;token&quot;: {
    &quot;methods&quot;: [ &quot;password&quot; ],
    &quot;roles&quot;: [{&quot;id&quot;: &quot;5642056d336b4c2a894882425ce22a86&quot;, &quot;name&quot;: &quot;admin&quot;}],
    &quot;expires_at&quot;: &quot;2015-12-25T09:57:28.404275Z&quot;,
    &quot;project&quot;: {
      &quot;domain&quot;: { &quot;id&quot;: &quot;default&quot;, &quot;name&quot;: &quot;Default&quot;},
      &quot;id&quot;: &quot;144d8a99a42447379ac37f78bf0ef608&quot;, &quot;name&quot;: &quot;admin&quot;},
    &quot;catalog&quot;: [
      {
        &quot;endpoints&quot;: [
          {
            &quot;region_id&quot;: &quot;RegionOne&quot;,
            &quot;url&quot;: &quot;http://controller:5000/v2.0&quot;,
            &quot;region&quot;: &quot;RegionOne&quot;,
            &quot;interface&quot;: &quot;public&quot;,
            &quot;id&quot;: &quot;3837de623efd4af799e050d4d8d1f307&quot;
          },
          ......
      ]}],
    &quot;extras&quot;: {},
    &quot;user&quot;: {
      &quot;domain&quot;: {&quot;id&quot;: &quot;default&quot;, &quot;name&quot;: &quot;Default&quot;},
      &quot;id&quot;: &quot;1552d60a042e4a2caa07ea7ae6aa2f09&quot;, &quot;name&quot;: &quot;admin&quot;},
    &quot;audit_ids&quot;: [&quot;ZCvZW2TtTgiaAsVA8qmc3A&quot;],
    &quot;issued_at&quot;: &quot;2015-12-25T08:57:28.404304Z&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;token_data 经 cms.cms_sign_token 签名生成的 token_id 如下，共 1932 Byte：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MIIKoZIhvcNAQcCoIIFljCCBZICAQExDTALBglghkgBZQMEAgEwggPzBgkqhkiG9w0B
......
rhr0acV3bMKzmqvViHf-fPVnLDMJajOWSuhimqfLZHRdr+ck0WVQosB6+M6iAvrEF7v
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-pkiz&quot;&gt;PKIZ&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/pkiz.png&quot; alt=&quot;P3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PKIZ 在 PKI 的基础上做了压缩处理，但是压缩的效果极其有限，一般情况下，压缩后的大小为 PKI token 的 90 % 左右，所以 PKIZ 不能友好的解决 token size 太大问题。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def _get_token_id(self, token_data):
    try:
        token_json = jsonutils.dumps(token_data, cls=utils.PKIEncoder)
        token_id = str(cms.pkiz_sign(token_json,
                                     CONF.signing.certfile,
                                     CONF.signing.keyfile))
        return token_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 cms.pkiz_sign() 中的以下代码调用 zlib 对签名后的消息进行压缩级别为 6 的压缩。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;compressed = zlib.compress(token_id, compression_level=6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PKIZ token 样例如下，共 1645 Byte，比 PKI token 减小 14.86 %：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PKIZ_eJytVcuOozgU3fMVs49aTXhUN0vAQEHFJiRg8IVHgn5OnA149JVaunNS3NYjoSU
......
W4fRaxrbNtinojheVICXYrEk0oPX6TSnP71IYj2e3nm4MLy7S84PtIPDz4_03IsOb2Q=
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-fernet&quot;&gt;Fernet&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/fernet.png&quot; alt=&quot;P4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用户可能会碰上这么一个问题，当集群运行较长一段时间后，访问其 API 会变得奇慢无比，究其原因在于 Keystone 数据库存储了大量的 token 导致性能太差，解决的办法是经常清理 token。为了避免上述问题，社区提出了&lt;a href=&quot;https://github.com/openstack/keystone-specs/blob/master/specs/kilo/klwt.rst&quot;&gt;Fernet token&lt;/a&gt;，它采用 &lt;a href=&quot;http://cryptography.readthedocs.org/en/latest/fernet/&quot;&gt;cryptography&lt;/a&gt; 对称加密库(symmetric cryptography，加密密钥和解密密钥相同) 加密 token，具体由 AES-CBC 加密和散列函数 SHA256 签名。&lt;a href=&quot;http://cryptography.readthedocs.org/en/latest/fernet/&quot;&gt;Fernet&lt;/a&gt;&lt;br /&gt;
是专为 API token 设计的一种轻量级安全消息格式，不需要存储于数据库，减少了磁盘的 IO，带来了一定的&lt;a href=&quot;http://dolphm.com/benchmarking-openstack-keystone-token-formats/&quot;&gt;性能提升&lt;/a&gt;。为了提高安全性，需要采用 &lt;a href=&quot;http://lbragstad.com/fernet-tokens-and-key-rotation/&quot;&gt;Key Rotation&lt;/a&gt; 更换密钥。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def create_token(self, user_id, expires_at, audit_ids, methods=None,
                 domain_id=None, project_id=None, trust_id=None,
                 federated_info=None):
    &quot;&quot;&quot;Given a set of payload attributes, generate a Fernet token.&quot;&quot;&quot;

    if trust_id:
        version = TrustScopedPayload.version
        payload = TrustScopedPayload.assemble(
            user_id,
            methods,
            project_id,
            expires_at,
            audit_ids,
            trust_id)

    ...

    versioned_payload = (version,) + payload
    serialized_payload = msgpack.packb(versioned_payload)
    token = self.pack(serialized_payload)

    return token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码表明，token 包含了 user_id，project_id，domain_id，methods，expires_at 等信息，重要的是，它没有 service_catalog，所以 region 的数量并不影响它的大小。self.pack() 最终调用如下代码对上述信息加密：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def crypto(self):
    keys = utils.load_keys()

    if not keys:
        raise exception.KeysNotFound()

    fernet_instances = [fernet.Fernet(key) for key in utils.load_keys()]
    return fernet.MultiFernet(fernet_instances)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;该 token 的大小一般在 200 多 Byte 左右，本例样式如下，大小为 186 Byte：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gAAAAABWfX8riU57aj0tkWdoIL6UdbViV-632pv0rw4zk9igCZXgC-sKwhVuVb-wyMVC9e5TFc
7uPfKwNlT6cnzLalb3Hj0K3bc1X9ZXhde9C2ghsSfVuudMhfR8rThNBnh55RzOB8YTyBnl9MoQ
XBO5UIFvC7wLTh_2klihb6hKuUqB6Sj3i_8
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-token&quot;&gt;如何选择 Token&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Token 类型&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;UUID&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;PKI&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;PKIZ&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Fernet&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大小&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;32 Byte&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;KB 级别&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;KB 级别&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;约 255 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持本地认证&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;不支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Keystone 负载&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;小&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;大&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;存储于数据库&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;携带信息&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;user, catalog 等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;user, catalog 等&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;user 等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;涉及加密方式&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;非对称加密&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;非对称加密&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;对称加密(AES)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是否压缩&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;是&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;版本支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;D&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;G&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;J&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;K&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;   &lt;br /&gt;
Token 类型的选择涉及多个因素，包括 Keystone server 的负载、region 数量、安全因素、维护成本以及 token 本身的成熟度。region 的数量影响 PKI/PKIZ token 的大小，从安全的角度上看，UUID 无需维护密钥，PKI 需要妥善保管 Keystone server 上的私钥，Fernet 需要周期性的更换密钥，因此从安全、维护成本和成熟度上看，UUID &amp;gt; PKI/PKIZ &amp;gt; Fernet 如果：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Keystone server 负载低，region 少于 3 个，采用 UUID token。&lt;/li&gt;
  &lt;li&gt;Keystone server 负载高，region 少于 3 个，采用 PKI/PKIZ token。&lt;/li&gt;
  &lt;li&gt;Keystone server 负载低，region 大与或等于 3 个，采用 UUID token。&lt;/li&gt;
  &lt;li&gt;Keystone server 负载高，region 大于或等于 3 个，K 版本及以上可考虑采用 Fernet token。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 26 Dec 2015 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/openstack/2015/12/26/%E7%90%86%E8%A7%A3Keystone%E7%9A%84%E5%9B%9B%E7%A7%8DToken.html</link>
        <guid isPermaLink="true">http://wsfdl.com/openstack/2015/12/26/%E7%90%86%E8%A7%A3Keystone%E7%9A%84%E5%9B%9B%E7%A7%8DToken.html</guid>
        
        
        <category>openstack</category>
        
      </item>
    
  </channel>
</rss>
