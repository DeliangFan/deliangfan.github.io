<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>http://wsfdl.com/</link>
    <atom:link href="http://wsfdl.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Feb 2017 10:00:38 +0800</pubDate>
    <lastBuildDate>Thu, 09 Feb 2017 10:00:38 +0800</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>理解 Consistent Hashing</title>
        <description>&lt;h1 id=&quot;id-section&quot;&gt;简介&lt;/h1&gt;

&lt;p&gt;为了解决分布式 web 中的热点问题，&lt;a href=&quot;https://en.wikipedia.org/wiki/David_Karger&quot;&gt;David Karger&lt;/a&gt; 于 1997 年提出 &lt;a href=&quot;https://en.wikipedia.org/wiki/Consistent_hashing&quot;&gt;一致性哈希(Consistent Hashing)&lt;/a&gt;，论文请见 &lt;a href=&quot;https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf&quot;&gt;Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web(较难理解)&lt;/a&gt;。一致性哈希广泛的运用于多种分布式系统中，如 memcache/redis，gluster file system, zookooper 等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Swift: &lt;a href=&quot;http://docs.openstack.org/developer/swift/ring_background.html&quot;&gt;Building a Consistent Hashing Ring&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Cassandra: &lt;a href=&quot;https://blog.imaginea.com/consistent-hashing-in-cassandra/&quot;&gt;Consistent Hashing in Cassandra&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Redis/Memcache: &lt;a href=&quot;http://get.ftqq.com/7057.get&quot;&gt;Memcache的一致性hash算法使用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文主要介绍一致性哈希的原理。&lt;/p&gt;

&lt;h1 id=&quot;id-section-1&quot;&gt;原理&lt;/h1&gt;

&lt;h2 id=&quot;id-section-2&quot;&gt;去中心与水平扩展&lt;/h2&gt;

&lt;p&gt;以 web 为例，cache 节点(如 Redis, Memcache)广泛用于 web 中，以提升性能。随着 web 规模扩大，单个节点无论是从性能上还是容量上都无法支撑大规模的业务，所以需要用多个节点以提升性能和容量。&lt;/p&gt;

&lt;p&gt;在多个节点下，给定某个 object，客户端如何知道它存储在哪个节点呢？最简单的做法是选取某个节点做为元数据服务器，记录每个 object 存放的节点，每次访问该 object 时，客户端首先访问元数据服务器，获取其所存放的节点，最后从该节点获取 object。元数据服务器需要维护所有 object 的位置信息，并且每次访问 object 都需要先访问元数据服务器，如此，元数据服务器容易成为性能和容量的瓶颈，不利于大规模扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          1. Fetch       +-----------------+
client  -------------&amp;gt;   | Metadata Server |   bottleneck
           Location      +-----------------+
       
          2. Access      +-----------------+
        -------------&amp;gt;   | Cache Server X  |
         Cache Server    +-----------------+           
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;去中心化的系统最大优点之一就是易水平扩展&lt;/strong&gt;，那是否有办法可以去除上述元数据服务器呢。答案是肯定的，比如计算 object 的 hash 值，然后均匀的分布到各个节点上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hash(object) mod N        其中 N 为节点数目
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如果某个节点宕机，剔除宕机节点后数目为 N - 1，此时映射关系变为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hash(object) mod (N - 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外，可能由于负载过高，需要新增一个节点，此时映射关系为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hash(object) mod (N + 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;无论是增加还是减少节点，都有可能会改变映射关系，造成大量请求的 miss。那是否能避免大量的 miss 呢？答案也是肯定的，&lt;strong&gt;一致性哈希解决了节点增减造成大量 hash 重定位的问题&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;id-section-3&quot;&gt;原理与增删节点&lt;/h2&gt;

&lt;p&gt;一致性哈希的原理如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将每个节点(node)映射到数值空间 [0, 2^32 - 1]，映射的规则可为 IP、hostname 等。&lt;/li&gt;
  &lt;li&gt;将每个 object 映射到数值空间 [0, 2^32 - 1]。&lt;/li&gt;
  &lt;li&gt;对于某个 object，对于所有满足 hash(node) &amp;lt;= hash(object) 的节点，选择 hash(node) 最大的节点存放 object。如果没有满足上述条件的节点，选择 hash(node) 最小的节点存放该 object，如下图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/hashring.png&quot; alt=&quot;hash ring&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当某个节点宕机时，仅有该节点的对象被重哈希到相邻节点上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/hashringdelete.png&quot; alt=&quot;hash ring delete&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与此类似，当新增一个节点时，仅有一个节点的部分 object 需要重哈希。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/hashringadd.png&quot; alt=&quot;hash ring add&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;id-section-4&quot;&gt;虚节点与平衡性&lt;/h2&gt;

&lt;p&gt;节点的位置是由自身哈希值决定的，它们的分布并非均匀，特别当节点数目很少时，容易造成 object 的分布不均匀，即平衡性低，例如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/hashringubalance.png&quot; alt=&quot;unbalance&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了解决这个问题，我们引入虚拟节点，虚拟节点实际上是物理节点的复制品，一个物理节点包含多个虚拟节点，我们将这些虚拟节点映射到数值空间 [0, 2^32 - 1]，对于某个 object，我们根据上节步骤计算该 object 存放的虚拟节点，进而得出物理节点。如下图共有 2 个物理节点，每个物理节点有三个虚拟机节点。当虚拟节点越多，虚拟节点的位置分布越均匀，相应的，映射到物理节点的 object 数目也越均匀，提高了平衡性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/hashringvn.png&quot; alt=&quot;virtual node&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;id-section-5&quot;&gt;总结&lt;/h1&gt;

&lt;p&gt;通过一致性哈希，客户端可以在本地计算 object 的存放位置，去除了中心节点，使得系统容易水平扩展，便于按需提升/降低整体的容量和性能，同时避免了每次增删节点造成大量哈希重定位的问题，最大化的减少了数据迁移。为使 object 能够尽可能均衡的分散在各个节点上，一致性哈希引入了虚节点，以提高平衡性。&lt;/p&gt;
</description>
        <pubDate>Sat, 28 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/algorithm/2017/01/28/%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.html</link>
        <guid isPermaLink="true">http://wsfdl.com/algorithm/2017/01/28/%E7%90%86%E8%A7%A3%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>同局域网下的 Iptables DNAT</title>
        <description>&lt;p&gt;某业务运行在服务器 A(10.0.0.2:80)，后来将其迁移至服务器 B(10.0.0.3:80)，为了保证平滑迁移，服务器 A 需要将 80 端口的入口流量转发至服务器 B 的 80 端口。&lt;a href=&quot;http://ipset.netfilter.org/iptables.man.html&quot;&gt;Iptables&lt;/a&gt; 强大的端口转发功能可以很好的满足该需求，因为服务器 A 需要将入口流量转发，因此使用 &lt;a href=&quot;http://linux-ip.net/html/nat-dnat.html&quot;&gt;DNAT&lt;/a&gt;。&lt;a href=&quot;https://www.netfilter.org/documentation/HOWTO/NAT-HOWTO-6.html&quot;&gt;官网文档&lt;/a&gt;的步骤如下：&lt;/p&gt;

&lt;p&gt;开启转发功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sysctl -w net.ipv4.ip_forward=1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置如下转发规则，即把 A 的 80 端口的流量转发到服务器 B 的 80 端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to  10.0.0.3:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后从客户端(10.0.0.10)访问服务器 A 的 80 端口，但是没有回应，原因是超时。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ curl http://10.0.0.2:80
curl: (7) Failed to connect to 10.0.0.2 port 80: Operation timed out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器 A 的抓包如下，由第一行可知服务器 A 的 80 端口收到请求，第二行表示服务器 A 将 80 端口的流量转发至服务器 B 的 80 端口(请注意相同的 TCP 序列号)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ tcpdump port 80
... IP 10.0.0.10.52799 &amp;gt; 10.0.0.2.80 Flags [S], seq 100071038, ... length 0
... IP 10.0.0.10.52799 &amp;gt; 10.0.0.3.80 Flags [S], seq 100071038, ... length 0
... (repeat the two lines above)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器 B 的抓包如下，第一行表示服务器 B 收到 TCP 三次握手中的 sync 报文，之后服务器回送 sync 报文(第二行)，第三行表示收到客户端 reset 报文。客户端之所以发送 reset 报文，是因为客户端是和服务器 A 而非 B 建立的 TCP 链接，所以服务器 B 回送 sync 报文时，客户端并不认识服务器 B，故客户端重置连接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ tcpdump port 80
... IP 10.0.0.10.52799 &amp;gt; 10.0.0.3.80: Flags [S], seq 100071038 ... length 0
... IP 10.0.0.3.80 &amp;gt; 10.0.0.10.52799: Flags [S.], seq 2076971142, ack 100071039 ... length 0
... IP 10.0.0.10.52799 &amp;gt; 10.0.0.3.80: Flags [R], seq 100071039 ... length 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分析清楚原因后，对于该问题，解决的办法有多种，最为便捷的是在服务器 A 对 80 端口的流量上再做 SNAT。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iptables -t nat -A POSTROUTING -d 10.0.0.3 -p tcp --dport 80 -j SNAT --to-source 10.0.0.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Serverfault 亦有人提出类似问题 &lt;a href=&quot;http://serverfault.com/questions/586486/how-to-do-the-port-forwarding-from-one-ip-to-another-ip-in-same-network&quot;&gt;how-to-do-the-port-forwarding-from-one-ip-to-another-ip-in-same-network&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/%E8%B8%A9%E5%9D%91%E6%9D%82%E8%AE%B0/2017/01/12/iptables_snat.html</link>
        <guid isPermaLink="true">http://wsfdl.com/%E8%B8%A9%E5%9D%91%E6%9D%82%E8%AE%B0/2017/01/12/iptables_snat.html</guid>
        
        
        <category>踩坑杂记</category>
        
      </item>
    
      <item>
        <title>[行摄] 泰山</title>
        <description>&lt;p&gt;泰山不亏为中华名山，自岱庙至玉皇顶共六七千余台阶，沿途林立着具有数百年历史的道观、寺庙、尼姑庵和关帝庙，碑林无数，尤其是明清时代的碑文保存完整，这些经历千百年风吹雨淋的古迹，见证了多少来往之人的历史故事，上至帝王、下至平民，既有得志之士，也有迁客骚人，积淀了多少文化。&lt;/p&gt;

&lt;p&gt;特别喜欢孟子的一段话：“孔子登东山而小鲁，登泰山而小天下。故观于海者难为水，游于圣人之门者难为言。观水有术，必观其澜。日月有明，容光必照焉。流水之为物也，不盈科不行；君子之志于道也，不成章不达。&lt;/p&gt;

&lt;p&gt;今朝登顶泰山，祈福新年之福祉，更将此话送予自己：观水有术，必观其澜！&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P1. 三朝庙&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG11ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p1&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P2. 泰山十八盘&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG10ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p2&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P3. 日之将出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG1ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p3&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P4. 泰山日出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG2ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p4&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P5. 泰山日出&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG3ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p5&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P6. 剪影&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG5ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p6&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P7. 青帝庙门&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG7ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p7&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P8. 玉皇顶远眺&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG6ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p8&quot; /&gt;&lt;/p&gt;

&lt;p&gt;P9. 千山朝雪&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG8ts.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p9&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 01 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/photos/2017/01/01/%E6%B3%B0%E5%B1%B1.html</link>
        <guid isPermaLink="true">http://wsfdl.com/photos/2017/01/01/%E6%B3%B0%E5%B1%B1.html</guid>
        
        
        <category>photos</category>
        
      </item>
    
      <item>
        <title>[行摄] 苏州</title>
        <description>&lt;p&gt;在浙江上海已六年，竟未到苏州，遂择十二月暖冬前往，游览博物馆、拙政园和留园。&lt;/p&gt;

&lt;p&gt;苏州博物馆出自&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B4%9D%E8%81%BF%E9%93%AD&quot;&gt;贝聿铭&lt;/a&gt;大师之手，他曾在祖宅狮子林度过一段儿童岁月，对园林的理解更为深刻。苏州博物馆多用几何形体，现代的建筑结构，简洁的风格。在建筑手法上与传统的园林风格多有差异之处，却与旁边的拙政园毫无违和之感，形不似而神似！博物馆内的假山，摈弃传统的太湖石，却更似假山！&lt;/p&gt;

&lt;p&gt;拙政园和留园是园林的典范，拙政园格局大气，留园精致美观，是拍摄旗袍、汉服的绝佳场所。&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P1. 苏州博物馆&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG5.jpeg?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p1&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P2. 苏州博物馆&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG6.jpeg?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p2&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P3. 苏州博物馆&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG3.jpeg?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p3&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P4. 拙政园&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG8.jpeg?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p4&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P5. 留园&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG15.jpeg?imageView2/1/w/800/h/533/q/100&quot; alt=&quot;p5&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P6. 留园&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG16.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p6&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P7. 留园&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG10.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p7&quot; /&gt;&lt;/p&gt;

&lt;p&gt; &lt;br /&gt;
 &lt;/p&gt;

&lt;p&gt;P8. 留园&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/WechatIMG12.jpeg?imageView2/1/w/800/h/800/q/100&quot; alt=&quot;p7&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/photos/2016/12/18/%E8%8B%8F%E5%B7%9E.html</link>
        <guid isPermaLink="true">http://wsfdl.com/photos/2016/12/18/%E8%8B%8F%E5%B7%9E.html</guid>
        
        
        <category>photos</category>
        
      </item>
    
      <item>
        <title>LVM 扩展逻辑卷</title>
        <description>&lt;h1 id=&quot;id-overview&quot;&gt;Overview&lt;/h1&gt;

&lt;p&gt;对于早期 Linux 用户，如何准确地评估分区的大小以及分配合适的空间一直是安装系统时的难题，因为在普通磁盘分区的管理下，分区划分后无法在不影响数据和系统运行的条件下改变其大小，当某个分区的存储空间消耗殆尽时，往往需要更换磁盘并迁移数据，如此可能会影响业务的正常运行。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_Volume_Manager_(Linux)&quot;&gt;LVM(Logical Volume Management)&lt;/a&gt; 的出现完美的解决上述问题，它是建立在硬盘和文件系统之间的一个逻辑层，支持动态的调整文件系统的大小，增添硬盘等，提高了存储空间管理的灵活性。LVM 大有先破后立之感，它把多块硬盘组成一个资源池，再按需从资源池划分虚拟分区，并且可以动态调整虚拟分区的大小和数量，它有以下三个重要概念。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.centos.org/docs/5/html/Cluster_Logical_Volume_Manager/physical_volumes.html&quot;&gt;Physical Volume(PV)&lt;/a&gt;：建立在物理分区之上，每个分区可以创建一个 PV。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.centos.org/docs/5/html/Cluster_Logical_Volume_Manager/volume_group_overview.html&quot;&gt;Volume Group(VG)&lt;/a&gt;：建立在 PV 之上，由一个或者多个 PV 组成，每个 PV 只能加入到一个 VG 中。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.centos.org/docs/5/html/Cluster_Logical_Volume_Manager/lv_overview.html&quot;&gt;Logical Volume(LV)&lt;/a&gt;：它是从 VG 划分的一块虚拟分区，可动态调整大小，一个 VG 可划分出多个 LV，这些 LV 可被格式化成文件系统并挂载在相关目录下。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;                   +-----------+ +------------+ +------+
File System        |  / (ext4) | | /var (xfs) | |  ... |
                   +-----------+ +------------+ +------+
                -------------------------------------------
                   +-----------+ +------------+ +------+
Logical Volume     |  lv-root  | |   lv-var   | |  ... |
                   +-----------+ +------------+ +------+
                -------------------------------------------
                   +-----------------------------------+
Volume Group       |                 vg                |
                   +-----------------------------------+
                ------------------------------------------- 
                   +---------------+   +---------------+
Physical Volume    |      pvsda1   |   |    pvsdb1     |
                   +---------------+   +---------------+
                -------------------------------------------
                   +---------------+   +---------------+
Disk partitions    |      sda1     |   |      sdb1     |
                   +---------------+   +---------------+
                -------------------------------------------
                   +---------------+   +---------------+
Disk               |      sda      |   |      sdb      |
                   +---------------+   +---------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;id-guide&quot;&gt;Guide&lt;/h1&gt;

&lt;p&gt;以本人 Linux 机器为例，根目录的空间使用率已达到 83%，扩容步骤如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# df -T
Filesystem                  Type     1K-blocks     Used Available Use% Mounted on
/dev/mapper/ubuntu--vg-root ext4      18180876 14265152   2969140  83% /
none                        tmpfs            4        0         4   0% /sys/fs/cgroup
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;它仅有一块磁盘 sda，分区 sda5 是最主要的分区，占据绝大多数存储空间，该分区属于一个名为 ubuntu-vg 的 VG，该 VG 包含两个 LV，分别是挂载在根目录的 ubuntu-vg-root 和用作 swap 的 ubuntu-vg-swap_1。该 VG 已无剩余空间，如果要扩展根目录的空间，就必须先增加磁盘，再扩展 ubuntu-vg VG，最后扩展 ubuntu-vg-root LV。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# pvdisplay
  --- Physical volume ---
  PV Name               /dev/sda5
  VG Name               ubuntu-vg
  PV Size               19.76 GiB / not usable 2.00 MiB
  
root@ubuntu:~# vgdisplay
  --- Volume group ---
  VG Name               ubuntu-vg
  ...
  Alloc PE / Size       5053 / 19.74 GiB
  Free  PE / Size       5 / 20.00 MiB

root@ubuntu:~# lvdisplay
  --- Logical volume ---
  LV Path                /dev/ubuntu-vg/root
  VG Name                ubuntu-vg
  LV Size                17.74 GiB
  ...

  --- Logical volume ---
  LV Path                /dev/ubuntu-vg/swap_1
  VG Name                ubuntu-vg
  LV Size                2.00 GiB
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先增加一块磁盘 sdb，利用 &lt;a href=&quot;https://linux.die.net/man/8/fdisk&quot;&gt;fdisk&lt;/a&gt; 在该磁盘创建一个名为 sdb1 的扩展分区，分区的大小和磁盘相当。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# fdisk /dev/sdb
...
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 1
First sector (2048-41943039, default 2048):
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-41943039, default 41943039):
Using default value 41943039

Command (m for help): t
Selected partition 1
Hex code (type L to list codes): 8e
Changed system type of partition 1 to 8e (Linux LVM)

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用 &lt;a href=&quot;https://linux.die.net/man/8/pvcreate&quot;&gt;pvcreate&lt;/a&gt; 在分区 sdb1 上创建一个名为 sdb1 的 PV：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# pvcreate /dev/sdb1
  Physical volume &quot;/dev/sdb1&quot; successfully created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把刚刚创建的 sdb1 PV 加入到 VG 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# vgextend ubuntu-vg /dev/sdb1
 Volume group &quot;ubuntu-vg&quot; successfully extended
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时 ubuntu-vg 总容量为 39.74 GB，可用空间为 20 GB：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# vgdisplay
  --- Volume group ---
  VG Name               ubuntu-vg
  VG Size               39.75 GiB
  PE Size               4.00 MiB
  Total PE              15296
  Alloc PE / Size       5053 / 19.74 GiB
  Free  PE / Size       5124 / 20.02 GiB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来扩展 /dev/ubuntu-vg/root LV，本次增加 10GB 的空间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# lvextend -L+10G /dev/ubuntu-vg/root
  Extending logical volume root to 27.74 GiB
  Logical volume root successfully resized
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展了逻辑卷后，还需要更新文件系统，因为 /dev/ubuntu-vg/root 上的文件系统类型为 ext4，所以 resize2fs 命令扩展。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# resize2fs /dev/mapper/ubuntu--vg-root
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展后效果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;root@ubuntu:~# df -T
Filesystem                  Type     1K-blocks     Used Available Use% Mounted on
/dev/mapper/ubuntu--vg-root ext4      28502156 14265156  12871324  53% /
none                        tmpfs            4        0         4   0% /sys/fs/cgroup
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 10 Dec 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/devops/2016/12/10/LVM_extend_directory.html</link>
        <guid isPermaLink="true">http://wsfdl.com/devops/2016/12/10/LVM_extend_directory.html</guid>
        
        
        <category>devops</category>
        
      </item>
    
      <item>
        <title>《人月神话》贵族专制和民主政治章节读后感</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This great church is an incomparable work of art. There is neither aridity nor confusion in the tenets it sets forth. . . . It is the zenith of a style, the work of artists who had understood and assimilated all their predecessors ‘ successes, in complete possession of the techniques of their times, but using them without indiscreet display nor gratuitous feats of skill.       &lt;br /&gt;
   &lt;/p&gt;

  &lt;p&gt;It was Jean d’Orbais who undoubtedly conceived the general plan of the building, a plan which was respected, at least in its essential elements, by his successors. This is one of the reasons for the extreme coherence and unity of the edifice.&lt;br /&gt;
   &lt;/p&gt;

  &lt;p&gt;                                                                                    ———《人月神话》贵族专制和民主政治章节序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大型的软件往往非常复杂，概念之多，功能之多，模块之多，代码之多。如果把大型软件比作一座城市，宜居之城应该是大而有序，繁而不乱，美观和谐，而不是城中有村，村中有城，建筑风格，囊括中外，道路交通，曲值相交！和构建一个美观有序的大城市一样，软件开发也应当适当的追求完整性和一致性，化繁为简，整理归纳，追求易用性：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;功能与概念的复杂度的比值才是系统设计的最终测试标准。&lt;br /&gt;
   &lt;/p&gt;

  &lt;p&gt;每个部分必须反应相同的原理需求的一致平衡。在语法上，每个部分应使用相同的技巧；在语义上，应具有同样的相似性。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体来说，本人的理解是概念应当通俗易懂，功能应当易用，多而不乱。整体布局得当，模块之间和谐共生，研发遵守一定的规则和工具。适当追求完整性具有诸多优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;概念易懂&lt;/li&gt;
  &lt;li&gt;功能易用&lt;/li&gt;
  &lt;li&gt;降低沟通成本&lt;/li&gt;
  &lt;li&gt;提升研发效率&lt;/li&gt;
  &lt;li&gt;降低维护成本，减少不可预知的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至于如何获取概念的完整性，作者只是给了一个非常 high-level 的答案：“概念的完整性要求设计必须由一个人，或者非常少数互有默契的人员来实现。”至于更详细的操作，本人认为可以从产品和研发两个角度出发分析，当然，在追求一致性和软件规模之间应当有所取舍，规模越小，一致性要求降低；规模越大，一致性的要求越高。&lt;/p&gt;

&lt;p&gt;从产品的角度提高易用性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;提高产品概念的易懂性，一个产品的概念应该是易于理解的，最好能类比到生活中，盲目的创造各种新词可能并非是一个好的选择。&lt;/li&gt;
  &lt;li&gt;提高产品功能的易用性，功能之间应当具有操作的相似性。&lt;/li&gt;
  &lt;li&gt;提高产品的美感性，好的设计是美感大方的，布局、色彩、字体之间应当相衬相托。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从研发的角度提高一致性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一致的内核和操作系统&lt;/li&gt;
  &lt;li&gt;尽可能采用一致的编程语言，至少模块内应该使用同一编程语言，并且注意版本，同种语言不同版本间的库函数可能会有很大差异；不同的高级语言之间的调用请走网络协议，尽量不要直接调用，如 Python 代码调用 shell 脚本。&lt;/li&gt;
  &lt;li&gt;尽可能一致的数据库，如 mysql 和 postgres 功能类似，但是对一些细节处理不一致，容易引起问题。&lt;/li&gt;
  &lt;li&gt;一致的编码风格，每种编程语言在构建 UT 时加入代码规范检查。&lt;/li&gt;
  &lt;li&gt;统一的文档存放，风格一致的文档说明&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/2016/11/22/moon_people_char_4.html</link>
        <guid isPermaLink="true">http://wsfdl.com/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/2016/11/22/moon_people_char_4.html</guid>
        
        
        <category>编程随想</category>
        
      </item>
    
      <item>
        <title>大话编程中的 time</title>
        <description>&lt;p&gt;最近在 time 方面踩坑数个，加上对各类时间名词的含义含糊不清，遂在本文整理时间相关的名词。&lt;/p&gt;

&lt;h1 id=&quot;id-gmt&quot;&gt;格林威治天文台与格林威治时间（GMT）&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/Royal_Observatory_Greenwich_London.jpg&quot; alt=&quot;Royal_Observatory_Greenwich_London.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;                                                                           &lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Royal_Observatory_Greenwich_London.jpg&quot;&gt;原图出处&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E7%9A%87%E5%AE%B6%E5%A4%A9%E6%96%87%E5%8F%B0&quot;&gt;格林威治皇家天文台(Royal Observatory, Greenwich)&lt;/a&gt; 是英国国王查理二世于 1675 年在伦敦格林威治建造的一个综合性天文台，那时处于&lt;a href=&quot;[大航海时代](https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%86%E5%A4%A7%E5%8F%91%E7%8E%B0)&quot;&gt;大航海时代&lt;/a&gt;，在当时远洋航行意味着冒险：茫茫大洋上无法准确测量船只所在的经度。所以国王建造天文台并设立皇家天文学家的职位：“致力于以最忱治的关心和努力校正天体运动的星表，和恒星的位置，以便能正确的定出经度，使导航成为完美的艺术”。虽然格林威治天文台并没有解决航海经度的测量问题，但其名气之大，一度成为最活跃的天文台，如&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%AC%E5%88%9D%E5%AD%90%E5%8D%88%E7%B7%9A&quot;&gt;本初子午线&lt;/a&gt;就是经过该天文台的 0 度经线。&lt;/p&gt;

&lt;p&gt;顾名思义，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E5%B9%B3%E6%97%B6&quot;&gt;格林威治标准时间(Greenwich Mean Time，GMT)&lt;/a&gt; 即指皇家格林威治天文台的标准时间，自 1924 年 2 月 5 日开始，格林威治天文台每隔一小时会向全世界发放调时信息。理论上说，格林威治标准时间的正午是指当太阳横穿格林威治子午线的时间，但是地球在椭圆轨道里运动速度不均匀，这个时刻可能与&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%AA%E9%98%B3%E6%97%A5&quot;&gt;平太阳时&lt;/a&gt;有误差，最大误差达16分钟。&lt;a href=&quot;http://ajucs.com/2016/06/24/talk-about-time-and-timer.html&quot;&gt;所以格林威治天文台连续观测 365 个长短不一的天&lt;/a&gt;，然后求平均值得到一天的长度，称为平太阳日，即格林威治标准时间采用的是平太阳时间。&lt;/p&gt;

&lt;p&gt;由于地球每天的自转是不规则的，而且正在缓慢减速，因此格林威治时间已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）。&lt;/p&gt;

&lt;h1 id=&quot;id-utc&quot;&gt;原子时与协调世界时（UTC）&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%AD%90%E9%90%98&quot;&gt;原子时&lt;/a&gt;是一种基于原子的时间，它以原子共振频率标准来计算和保证时间的准确。原子时是世界上已知最准确的时间测量和频率标准，也是国际时间和频率转换的基准。&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%AD%90%E6%97%B6&quot;&gt;1967 年第 13 届国际计量大会上通过一项决议&lt;/a&gt;，定义一秒(原子时秒)为铯-133 原子基态两个超精细能级间跃迁辐射 9192631770 周所持续的时间。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Coordinated_Universal_Time&quot;&gt;协调世界时(Coordinated Universal Time, UTC)&lt;/a&gt; 又称世界标准时间或世界协调时间，是目前最主要的世界时间标准。它以原子时的秒为基础，和平太阳时相差不超过 1 秒，在时刻上尽量接近于格林威治标准时间。对于大多数用途来说，UTC 时间被认为能与 GMT 时间互换，但 GMT 时间已不再被科学界所确定。&lt;/p&gt;

&lt;p&gt;协调世界时把时间分为天、小时、分钟和秒，每天包含 24 小时，每小时包含 60 分钟，一分钟通常有 60 秒，但是分钟加入了闰秒，所以一分钟也可能是 61 秒或 59 秒。在 UTC 系统的时间尺度中，秒和比秒小的单位（毫秒、微秒等）其长度是固定的，但是对于分钟和比分还大的单位（小时、天、周等），其长度是可变的。可采用 date -u 获取 UTC 时间。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ date -u
Mon Nov 20 09:15:20 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;id-localtime-&quot;&gt;Localtime 与夏令时&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/Standard_World_Time_Zones.png&quot; alt=&quot;Time Zones&quot; /&gt;&lt;/p&gt;

&lt;p&gt;                                                                           &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA#/media/File:Standard_World_Time_Zones.png&quot;&gt;原图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;各个国家分布在地球的不同位置上，因此不同国家的日出、正午、日落时间可能有所偏差，在现实生活中，人们更关注本地时间，因为和 UTC 相比，本地时间更适合用于当地的生产和生活。1863 年，&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA&quot;&gt;时区&lt;/a&gt;的概念被首次提出，它以区域为范围设定标准时间，某地的本地时间通常指该地所在时区的标准时间。理论时区以被 15 整除的子午线为中心，向东西两侧延伸 7.5 度，即每 15 度划分一个时区，这是理论时区。但是，为了避开国界线，有的时区的形状并不规则，而且比较大的国家以国家内部行政分界线为时区界线，这是实际时区，即法定时区。&lt;/p&gt;

&lt;p&gt;北京位于东八区，故其时区为 UTC+8，北京时间比格林威治标准时间早 8 小时，在不考虑夏令时的情况下，可用以下公式完成本地时间和 UTC 时间之间的转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UTC + 时区差 = 本地时间
其中东半球时区威差为正，西半球时区差负。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%97%B6%E5%88%B6&quot;&gt;夏令时(Summer Time)&lt;/a&gt; 又称日光节约时制或日光节约时间，是一种为节约能源而人为规定地方时间的制度。一般在天亮较早的夏季人为将时间调快一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的国家具体规定不同，目前全世界有近 110 个国家每年要实行夏令时，如美国、欧盟等；中国、日本等国家曾经实行过夏令时，但是目前不予实行。&lt;/p&gt;

&lt;h1 id=&quot;id-unix-&quot;&gt;Unix 时间&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4&quot;&gt;Unix 时间&lt;/a&gt;又称 Posix 时间，它是 Unix 和 类 Unix 系统使用的表达方式，它指自 UTC 时间 1970 年 1 月 1 日 0 时 0 分 0 秒起值现在的总秒数，可用 date +%s 查看 Unix 时间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ date +%s
1479655113
$
$ date -r 1479655113
Sun Nov 20 15:18:33 UTC 2016
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由上可知，Unix 时间 1479655113 表示的日期为 Sun Nov 20 15:18:33 UTC 2016。&lt;/p&gt;

&lt;p&gt;现在有些系统采用 32 位有符号整数保存 Unix 时间，所以它最多只能表示 136 年，即：1901-12-13 20:45:52 至 2038-1-19 3:14:07。和 &lt;a href=&quot;https://zh.wikipedia.org/wiki/2000%E5%B9%B4%E9%97%AE%E9%A2%98&quot;&gt;千年虫问题&lt;/a&gt; 类似，32 位 Unix/Linux 的系统在 2038 年可能会发生故障。&lt;/p&gt;

&lt;p&gt;我们常用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Network_Time_Protocol&quot;&gt;NTP 协议&lt;/a&gt;校准计算机时间。&lt;/p&gt;

&lt;p&gt;一点感想：软件开发中，最好采用 UTC，分布式跨时区系统一定请用 UTC！&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/algorithm/2016/11/18/%E7%90%86%E8%A7%A3time.html</link>
        <guid isPermaLink="true">http://wsfdl.com/algorithm/2016/11/18/%E7%90%86%E8%A7%A3time.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Yield 和 Coroutine</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;This PEP proposes some enhancements to the API and syntax of generators, to make them usable as simple coroutines.&lt;/p&gt;

  &lt;p&gt;                                                                                                                                             ——— Pep342&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;博文 &lt;a href=&quot;http://wsfdl.com/python/2016/10/18/python_yield.html&quot;&gt;Iterator, Generator 与 Yield&lt;/a&gt; 介绍了 iterator，generator 和 yield，并阐述三者之间的关系。本文将进一步介绍 yield 和 coroutine，并阐述如何通过 yield 实现一个简单的 coroutine。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;Coroutine(协程)&lt;/a&gt; 最早于 1963 年提出，在之后的三四十年里并没有受到广泛关注，但在近些年受到热捧。通俗而言：协程相当于用户态线程。这句话包含了两层意思：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;协程具有类似线程的功能，它能提供并发。&lt;/li&gt;
  &lt;li&gt;协程是用户态的，即操作系统对协程不感知，也不负责调度；应用程序负责管理协程的生命周期和调度协程，由于协程的切换是函数级别的切换，故切换的开销远远小于线程/进程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么协程在近些年越来越火？原因得从并发谈起，随着互联网爆炸式增长，服务端对并发能力的需求越来越大。最初工程师采用多进程提供并发，每当服务端收到一个请求，就 fork 一个进程处理请求，Apache 是最典型的例子。但是进程很重，占用了的大量 CPU 和内存资源，和进程相比，线程占用更少的资源，所以多线程的并发模型更受欢迎，每当服务端收到一个请求，就创建一个线程处理请求，如 Nginx。每个线程维护私有的 stack，Linux 下 stack 的默认大小为 8MB，所以 8G 内存的 Linux 服务器最多能创建 1000 个线程；此外线程的调度由内核负责，调度和切换的开销也不容小觑，以上两个因素限制了多线程模型的并发能力。&lt;/p&gt;

&lt;p&gt;为了提升服务端的并发能力，我们需要一种并发模型，这种模型具有以下特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;占用更少的资源，如内存和 CPU 周期&lt;/li&gt;
  &lt;li&gt;避免内核调度带来的额外开销，协程仅在必要的时候才被调度切换，如 IO 操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而协程作为用户态线程，恰好满足上述要求，首先协程的 stack 比线程的 stack 更小，占用更少的内存空间(KB 级别)，无需通过系统调用来创建和销毁，故消耗更少的 CPU 周期；另外，协程的调度由应用程序负责，仅在必要的时候才切换，和线程相比，减少了切换的次数和每次切换的开销。&lt;/p&gt;

&lt;p&gt;回顾 Yield，我们用它编写一个如下的 Generator。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def task1():
    while True:
        # Do something
        yield &quot;This is task1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&amp;gt;&amp;gt;&amp;gt; t1 = task1()              # Initiate a task
&amp;gt;&amp;gt;&amp;gt; t1.next()                 # Run task
&amp;gt;&amp;gt;&amp;gt; This is task1             # Task suspend when meeting next yield
&amp;gt;&amp;gt;&amp;gt; t1.Send(None)             # Run task
&amp;gt;&amp;gt;&amp;gt; This is task1             # Task suspend when meeting next yield
&amp;gt;&amp;gt;&amp;gt; t1.close()                # Delete task
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用一个包含 yield 的函数时，相当于初始化了一个协程，我们可以调用 next() 或者 send() 让协程运行，每当 task 遇到 yield 则自动暂停挂起，我们也可以调用 close() 结束一个协程。以下是进程，线程和上例协程生命周期管理的部分函数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Method          Process         Thread           Coroutine
----------------------------------------------------------------------
Create/Run      fork            pthread_create   task1()/next/send
Delete          exit            pthread_exit     close
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上例协程具备基本的生命周期管理的方法，我们现在往其加入调度功能，调度算法为 FIFO。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Scheduler(object):
    def __init__(self):
        self.queue = []
        self.task_num = 0

    def new(self, task):
        self.queue.append(task)
        self.task_num += 1

    def loop(self):
        while self.task_num:
            task = self.queue.pop(0)
            task.next()
            self.queue.append(task)


def task2():
    while True:
        # Do something
        yield &quot;This is task2&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&amp;gt;&amp;gt;&amp;gt; scheduler = Scheduler()
&amp;gt;&amp;gt;&amp;gt; scheduler.new(task1())
&amp;gt;&amp;gt;&amp;gt; scheduler.new(task2())
&amp;gt;&amp;gt;&amp;gt; scheduler.loop()
This is task1
This is task2
This is task1
This is task2
......
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;流程图如下，每当 Main Loop 调用 next()/send()，执行权交给相应协程，每当协程遇到 yield，则交出执行权给 Main Loop。该流程图和 Linux 的进程调度非常类似，如果把 Main Loop 比作内核，协程如同进程/线程，yield 如同系统调用、硬件中断等。任何时刻，一个 Python 进程内只有一个协程在执行，即协程是伪并发的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;           Run       Run      Run      Run      Run
Main Loop  ---&amp;gt;      --&amp;gt;      --&amp;gt;      --&amp;gt;      ---&amp;gt;
               |    |   |    |   |    |   |    |
               |Run |   |    |   |Run |   |    |     ......
Task1           ---&amp;gt;    |    |    ---&amp;gt;    |    |
                        |Run |            |Run |
Task2                    ---&amp;gt;              ---&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本文借用 yield 实现了一个非常简单的协程，它的调度功能非常简陋，不支持同步功能，没有处理阻塞的 IO，无法处理复杂事务，另推荐 &lt;a href=&quot;http://www.dabeaz.com/coroutines/&quot;&gt;A Curious Course on Coroutines and Concurrency&lt;/a&gt; 和 Python 协程库 &lt;a href=&quot;http://eventlet.net/&quot;&gt;eventlet&lt;/a&gt;，&lt;a href=&quot;http://www.gevent.org/&quot;&gt;gevent&lt;/a&gt; 做进一步的学习。&lt;/p&gt;
</description>
        <pubDate>Sun, 13 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/python/2016/11/13/yield_and_croutine.html</link>
        <guid isPermaLink="true">http://wsfdl.com/python/2016/11/13/yield_and_croutine.html</guid>
        
        
        <category>python</category>
        
      </item>
    
      <item>
        <title>赌书消得泼茶香</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xp2eu.com1.z0.glb.clouddn.com/book_home.jpeg&quot; alt=&quot;home book&quot; /&gt;&lt;br /&gt;
                                                                               书房&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们一拿起一本这样的古书来，即使只读半小时，也会觉得无比的轻松、愉快、清净、超逸，仿佛汲饮清冽的泉水似的舒适。&lt;/p&gt;

  &lt;p&gt;                                                                                                                                                      — 叔本华&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文所记的，正是 IT 领域如叔本华所说的古书。&lt;/p&gt;

&lt;h1 id=&quot;id-section&quot;&gt;技术类&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;《Operating System Concepts - 9th edition》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;曾尝试读过各类 Linux 书籍，无一以失败告终，究其原因，未知原理，先上代码，堆砌细节，难免一头雾水。此书高屋建瓴，提纲挈领的勾画操作系统的模型，从进程模型、进程调度、内存管理再到文件系统，每个部分由浅入深的介绍多种实现方式以及各自的优缺点，不仅知其然，而且知其所以然。理解此书后，再阅读 Linux/Unix 相关书籍，会轻松许多，若能结合伯克利的公开课 CS162，将事半功倍。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《Unix 环境高级编程（第三版）》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如今的内核源码已达千万行规模，大多数软件工程师没有必要去理解内核的具体的实现，但是应该知道内核能为我们提供什么功能，以及我们该如何使用这些功能。书中列举了数百个常用的系统调用，几乎覆盖了除网络编程外的方法面面，如：进程/线程、同步、信号和 IO 等。熟知此书，有利于迅速掌握一门语言，因为许多语言的内建和系统库正是基于这些系统调用。此书亦可做手册，用于工作查询，可闲暇翻阅，但中文翻阅很烂，最好阅读原版。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《TCP/IP 协议，卷 1》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我的专业是通信工程，学习了《信号与系统》、《通信原理》等书籍，但工作之中，却远不如 《TCP/IP》实用。从 LAN/VLAN，路由，再到 TCP/UDP，尤其是 TCP 几章，循序渐进，深入浅出！理解常用协议的报文及原理，再掌握 Linux 平台常用的网络工具，分析抓包，即可定位和解决常见网络问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《Unix 网络编程》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此书详细的介绍了 Unix 网络编程，从 90 年代起，网络经历了爆炸式的发展，作者把网络知识独立著成一书，可见对网络之重视。掌握了 TCP/IP 基础知识后，阅读此书，甚是通畅。本书主要讲解基于 UPD/TCP 的 socket 编程，IO 和并发模型是本书的精髓，如能结合 &lt;a href=&quot;http://www.kegel.com/c10k.html&quot;&gt;C10K&lt;/a&gt; 问题，将更有助于理解 IO 和并发模型。卷二的 RPC 也值得一读，因为许多分布式系统大量的使用了 RPC(高级) 解耦。&lt;/p&gt;

&lt;h1 id=&quot;id-section-1&quot;&gt;思想类&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;《人月神话》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;作者是 IBM OS/360 的负责人，此书写于 40 年前，但是许多关于大型项目开发的观点至今依旧深刻。如：人月不可替代，软件复杂度随代码指数增长，追求架构的一致性，大型项目下的人员组织架构等。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《黑客与画家》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;惊！奇！此书一气读完，仍不过瘾，再读一遍，越发深刻。如果说《人月神话》大型软件开发的圣经，《黑客与画家》则是互联网软件开发的圣经！作者对互联网软件的快速开发、迭代和发布，对编程语言的理解和剖析，是本书的最精彩之处。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;《硅谷之火》&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;《硅谷之火》介绍了 PC 的发展历史，从硬件、操作系统到上层的软件应用，诞生了多少公司和成就了多少人物，也谱写了多少故事。此外还有一部名为《硅谷海盗》的电影，值得一看。我想，此书应该是献给那些创业者，献给那些弄潮人。Good artist copy, Great artist steal。&lt;/p&gt;

&lt;h1 id=&quot;id-section-2&quot;&gt;论文&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf&quot;&gt;MapReduce: Simplified Data Processing on Large Clusters&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf&quot;&gt;Consistent Hashing and Random Trees: Distributed Caching Protocols for Relieving Hot Spots on the World Wide Web&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 06 Nov 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/2016/11/06/book.html</link>
        <guid isPermaLink="true">http://wsfdl.com/%E7%BC%96%E7%A8%8B%E9%9A%8F%E6%83%B3/2016/11/06/book.html</guid>
        
        
        <category>编程随想</category>
        
      </item>
    
      <item>
        <title>理解浮点数</title>
        <description>&lt;h1 id=&quot;id-example&quot;&gt;Example&lt;/h1&gt;

&lt;p&gt;首先从两个例子开始。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;例 1，下例输出是？&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;

void main(){
    float p = 1000000.9;

    printf(&quot;%f&quot;, p);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1000000.875000
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;例 2，下例输出是？&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include&amp;lt;stdio.h&amp;gt;

void main(){
    int i = 1;
    float* p = &amp;amp;i;

    printf(&quot;%f&quot;, *p);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0.000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;id-section&quot;&gt;理解浮点数&lt;/h1&gt;

&lt;p&gt;从例 1 可知，&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point&quot;&gt;浮点数&lt;/a&gt;表示的精度有限；由例 2 可知，同样为 4 Byte，float 和 int 的数据组织不一样。那么浮点数是如何组织的呢？首先回忆&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%A7%91%E5%AD%A6%E8%AE%B0%E6%95%B0%E6%B3%95&quot;&gt;科学计数法&lt;/a&gt;。在科学记数法中，一个有限的实数可用如下表示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a * 10^n

其中：
1 &amp;lt;= |a| &amp;lt; 10
n 为整数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上式子亦可表达为如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(-1)^s * a * 10^n

其中：
s = 0 或 1，s 为 0 表示正数，为 1 表示负数
1 &amp;lt;= a &amp;lt; 10
n 为整数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;计算机采用二进制，科学计数法的二进制表达如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(−1)^s × a × 2^n

其中
s = 0 或 1，s 为 0 表示正数，为 1 表示负数
1 &amp;lt;= a &amp;lt; 2
n 为整数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以 4 Byte 的 float 为例，&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-1985&quot;&gt;IEEE 754&lt;/a&gt; 对其的定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|s|exponent(8 bit)|            fraction (23 bit)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;s 表示符号位，共 1 bit，0 表示正数，1 表示负数&lt;/li&gt;
  &lt;li&gt;e(exponent) 共 8 bit，它决定了 n 的值，即浮点数能表达的范围&lt;/li&gt;
  &lt;li&gt;f(fraction) 共 23 bit，它决定了 a 的值，即浮点数的精度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;e 和 n 的关系如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;n = e - 127

其中 0&amp;lt;= e &amp;lt;= 255
所以 -127 &amp;lt;= n &amp;lt;= 128。(当 n = 128 时，表示浮点数无穷大)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;f 和 a 的关系如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a = f/(2^23) + 1

其中 0 &amp;lt;= f &amp;lt;= 8388607
所以 1 &amp;lt;= a &amp;lt;= 1.99999988
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以 float 类型的浮点数能表示的范围为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;± 1.99999988 * 2^-127 至 ± 1.99999988 * 2^127
即：± 1.18 × 10^-38 至 ± 3.4 × 10^38
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;float 类型的浮点数精度为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1/(2^23) = 1.19 * 10^-7，十进制下为 7 位。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同理，double 类型的浮点数能表示的范围和最大精度为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;范围：± 2.23 × 10^-308 到 ± 1.80 × 10^308
精度：十进制下为 16 位
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例 1 中，因为 1000000.9 长度为 8 位，超出 float 所能表示的最大精度，所以不能被精确表示。&lt;/p&gt;

&lt;p&gt;例 2 中，对于 int i = 1，其在内存中的数据为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;|s|exponent(8 bit)|            fraction (23 bit)                |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|1|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;故有 s = 0, e = 0, f = 1，其值为 (-1)^0 * (1 + 2^-23) * 2^-127，即 5.88 * 10^-39，所以显示的结果为 0。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Oct 2016 00:00:00 +0800</pubDate>
        <link>http://wsfdl.com/algorithm/2016/10/20/Floating_number.html</link>
        <guid isPermaLink="true">http://wsfdl.com/algorithm/2016/10/20/Floating_number.html</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
  </channel>
</rss>
